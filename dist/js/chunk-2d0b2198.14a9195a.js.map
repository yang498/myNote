{"version":3,"sources":["webpack:///./src/pages/article/jsType/object.vue?1d8a","webpack:///src/pages/article/jsType/object.vue","webpack:///./src/pages/article/jsType/object.vue?1861","webpack:///./src/pages/article/jsType/object.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,45TCR8W,I,YCO1WC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d0b2198.14a9195a.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# object\r\n\r\n## 概述\r\n\r\n### 定义\r\n\r\n一组无序键值对（key-value）的集合，以大括号包裹，键值对之间以逗号·,·分隔，键与值之间以冒号·:·分隔\r\n\r\n··js\r\nvar obj = {\r\n    foo: 'Hello',\r\n    bar: 'World'\r\n}\r\n\r\n// 修改增加\r\nobj.foo = 123\r\nobj.foo2 = 234\r\n··\r\n\r\n### 键名命名规范\r\n\r\n若省略引号则不能包含空格或运算符\r\n以数字开头和非数字字符的组合须加上引号\r\n\r\n··js\r\n// 报错\r\nvar obj = {\r\n    1p: 'Hello World'\r\n}\r\n\r\n// 不报错\r\nvar obj = {\r\n    20: 'Hello World',\r\n    p1: 'Hello World',\r\n    '1p': 'Hello World',\r\n    'h w': 'Hello World',\r\n    'p+q': 'Hello World'\r\n}\r\n··\r\n\r\n### 对象引用\r\n\r\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址\r\n修改其中一个变量，会影响到其他所有变量\r\n\r\n··js\r\nvar o1 = {}\r\nvar o2 = o1\r\n\r\no1.a = 1\r\no2.a // 1\r\n\r\no2.b = 2\r\no1.b // 2\r\n··\r\n\r\n但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝\r\n\r\n··js\r\nvar x = 1\r\nvar y = x\r\n\r\nx = 2\r\ny // 1\r\n··\r\n\r\n### 表达式还是语句？\r\n\r\n对象采用大括号表示，所以如果行首是一个大括号，它是表达式表示一个对象还是语句表示一段代码？\r\n为了避免这种歧义，JavaScript 引擎的做法是一律解释为代码块\r\n\r\n··js\r\n{ console.log(123) } // 123\r\n··\r\n\r\n如果要解释为对象，最好在大括号前加上圆括号。因为圆括号里面只能是表达式\r\n\r\n··js\r\n({ foo: 123 }) // 正确\r\n({ console.log(123) }) // 报错\r\n··\r\n\r\n这种差异在·eval·语句（作用是对字符串求值）中反映得最明显\r\n\r\n··js\r\neval('{foo: 123}') // 123\r\neval('({foo: 123})') // {foo: 123}\r\n··\r\n\r\n### 读取属性\r\n\r\n使用点运算符·.·或方括号运算符·[]·\r\n注意，使用方括号运算符·[]·时，键名必须放在引号里面（数字除外），否则是个变量\r\n方括号运算符内部还可以使用表达式运算\r\n\r\n··js\r\nvar obj = {\r\n    p: 'Hello World'\r\n}\r\n\r\nobj.p // \"Hello World\"\r\nobj['p'] // \"Hello World\"\r\n··\r\n\r\n### delete\r\n\r\n·delete·命令用于删除对象的属性，删除成功后返回·true·\r\n\r\n··js\r\nvar obj = { p: 1 }\r\ndelete obj.p\r\nobj // {}\r\n··\r\n\r\n注意，删除一个不存在或继承的属性，·delete·不报错且返回·true·，只有当该属性存在且不得删除时使用·delete·会返回·false·\r\n\r\n··js\r\nvar obj = Object.defineProperty({}, 'p', {\r\n    value: 123,\r\n    configurable: false\r\n})\r\nobj.p // 123\r\ndelete obj.p // false\r\n··\r\n\r\n### in\r\n\r\n·in·运算符用于检查对象是否包含某个属性（键名，不是键值），左边是属性名，右边是一个对象\r\n注意，继承的属性也会返回·true·，可使用对象的·hasOwnProperty·方法判断是否为对象自身的属性\r\n\r\n··js\r\nvar obj = { p: 1 }\r\n'p' in obj // true\r\n'toString' in obj // true\r\nobj.hasOwnProperty('toString') // false\r\n··\r\n\r\n### for...in\r\n\r\n遍历一个对象的全部属性\r\n\r\n··js\r\nvar obj = { a: 1, b: 2, c: 3 }\r\n\r\nfor (var i in obj) console.log(i)\r\n// a\r\n// b\r\n// c\r\n··\r\n\r\n### with\r\n\r\n操作同一个对象的多个属性时，提供一些书写的方便\r\n\r\n··js\r\nvar obj = {\r\n    p1: 1,\r\n    p2: 2\r\n}\r\n\r\nwith (obj) {\r\n    p1 = 4\r\n    p2 = 5\r\n}\r\n// 等同于\r\nobj.p1 = 4\r\nobj.p2 = 5\r\n··\r\n\r\n注意，·with·内部操作的必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量\r\n\r\n··js\r\nvar obj = {}\r\nwith (obj) {\r\n    p1 = 4\r\n}\r\n\r\nobj.p1 // undefined\r\np1 // 4\r\n··\r\n\r\n因此，不建议使用·with·语句，用一个临时变量代替\r\n\r\n## 属性描述对象\r\n\r\n### 介绍\r\n\r\nJavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等\r\n这个内部数据结构称为“属性描述对象”（attributes object），可通过一些静态方法来操作\r\n\r\n··js\r\n{\r\n    value: 123,\r\n    writable: true,\r\n    enumerable: true,\r\n    configurable: true,\r\n    get: undefined,\r\n    set: undefined\r\n}\r\n··\r\n\r\n!!\r\nvalue [undefined]：属性值\r\nwritable {Boolean} [true]：·value·是否可改变，若设为·false·可通过·Object.defineProperty/ies()·修改\r\nenumerable {Boolean} [true]：·value·是否可遍历\r\nconfigurable {Boolean} [true]：·value·是否可修改属性描述对象，和是否可删除此属性\r\n    若·configurable·设为·false·，则修改·writable·将·true·改为·false·是允许的\r\n    至于·value·，只要·writable·和·configurable·有一个为·true·，就允许改动\r\nget {Function}：取值函数（getter）\r\nset {Function}：存值函数（setter），接受赋予的值作为参数\r\n    注意，若定义了·get·或·set·，就不能将·writable·属性设为·true·，也不能设置·value·\r\n        因为此时获取该属性返回的不是·value·，而是·get·返回的值，同理，赋值时就会调用·set·\r\n!!\r\n\r\n### 写法\r\n\r\n第一种是通过·Object.defineProperty/ies()·定义：\r\n\r\n··js\r\nvar obj = Object.defineProperty({}, 'p', {\r\n    get: function () {\r\n        return 'getter'\r\n    },\r\n    set: function (value) {\r\n        console.log('setter: ' + value)\r\n    }\r\n})\r\n\r\nobj.p // \"getter\"\r\nobj.p = 123 // \"setter: 123\"\r\n··\r\n\r\n第二种是直接在对象上定义，方法名即属性名：\r\n\r\n··js\r\nvar obj = {\r\n    get p() {\r\n        return 'getter'\r\n    },\r\n    set p(value) {\r\n        console.log('setter: ' + value)\r\n    }\r\n}\r\n··\r\n\r\n### 用法\r\n\r\n存取器往往用于，属性的值依赖对象内部数据的场合：\r\n\r\n··js\r\n// next 属性的存值函数和取值函数，都依赖于内部属性 $n\r\nvar obj ={\r\n    $n : 5,\r\n    get next() { return this.$n++ },\r\n    set next(n) {\r\n        if (n >= this.$n) this.$n = n\r\n        else throw new Error('新的值必须大于当前值')\r\n    }\r\n}\r\n\r\nobj.next // 5\r\n\r\nobj.next = 10\r\nobj.next // 10\r\n\r\nobj.next = 5\r\n// Uncaught Error: 新的值必须大于当前值\r\n··\r\n\r\n### 对象的拷贝\r\n\r\n有时，我们需要将一个对象的所有属性，拷贝到另一个对象：\r\n\r\n··js\r\nvar extend = function (to, from) {\r\n    for (var property in from) to[property] = from[property]\r\n    return to\r\n}\r\n\r\nextend({}, { a: 1 }) // {a: 1}\r\n··\r\n\r\n但如果遇到存取器定义的属性，会只拷贝值：\r\n\r\n··js\r\nextend({}, {\r\n    get a() { return 1 }\r\n})\r\n// {a: 1}\r\n··\r\n\r\n可以通过·Object.defineProperty()·来拷贝属性描述对象\r\n\r\n··js\r\nvar extend = function (to, from) {\r\n    for (var property in from) {\r\n        if (from.hasOwnProperty(property)) {\r\n            Object.defineProperty(\r\n                to,\r\n                property,\r\n                Object.getOwnPropertyDescriptor(from, property)\r\n            )\r\n        }\r\n    }\r\n    return to\r\n}\r\n\r\nextend({}, { get a() { return 1 } })\r\n// { get a(){ return 1 } })\r\n··\r\n\r\n## Object\r\n\r\nJavaScript 的所有其他对象都继承自·Object·对象，即那些对象都是·Object·的实例\r\n\r\n### Object()\r\n\r\n·Object·本身是一个函数，可以当作工具方法使用，将任意值转为对象\r\n如果参数为空（或者为·undefined·和·null·），·Object()·返回一个空对象\r\n\r\n··js\r\nvar obj = Object()\r\nvar obj = Object(undefined)\r\nvar obj = Object(null)\r\n··\r\n\r\n### instanceof\r\n\r\n验证一个对象是否为指定的构造函数的实例\r\n当对·Object·函数传入原始类型的值时返回原始类型值对应的包装对象\r\n\r\n··js\r\nvar obj = Object(1)\r\nobj instanceof Object // true\r\nobj instanceof Number // true\r\n··\r\n\r\n如果·Object·方法的参数是一个对象则返回该对象，即不用转换\r\n\r\n··js\r\nvar value = {}\r\nvar obj = Object(value) // 返回原对象\r\nobj === value // true\r\n··\r\n\r\n判断变量是否为对象（包括数组、函数）：\r\n\r\n··js\r\nfunction isObject(value) {\r\n    return value === Object(value)\r\n}\r\n··\r\n\r\n### new Object()\r\n构造函数可以用来生成新对象，以下写法相等\r\n\r\n··js\r\nvar obj = new Object()\r\nvar obj = Object()\r\nvar obj = {}\r\n··\r\n\r\n其中·Object(value)·表示将·value·转成一个对象，·new Object(value)·则表示新生成一个对象\r\n\r\n## 静态方法\r\n\r\n!!\r\nObject.keys(obj)：返回一个由参数对象的键名组成的数组，只返回可遍历的属性\r\nObject.getOwnPropertyNames(obj)：用法和·Object.keys()·一样，且可返回不可遍历的属性，例如数组的·length·\r\n\r\nObject.getOwnPropertyDescriptor(obj, key)：获取属性描述对象，只能用于自身的属性，不能用于继承的属性\r\nObject.getPrototypeOf(obj)：获取对象的·Prototype·对象\r\nObject.create(obj)：指定原型对象和属性，返回一个新的对象，即复制对象\r\n\r\nObject.defineProperty(obj, key, attrObj)：定义或修改属性描述对象，返回修改后的对象\r\nObject.defineProperties(obj, {keys: attrObjs})：：定义或修改多个属性描述对象，返回修改后的对象\r\n    若·defineProperty/ies()·未定义·writable configurable enumerable·则默认都为·false·\r\n\r\nObject.preventExtensions(obj)：禁止对象添加新的属性\r\nObject.seal(obj)：禁止对象添加新的属性，也不能删除已有的属性，即把·configurable·属性设为·false·\r\nObject.freeze(obj)：禁止对象添加新属性、删除旧属性、改变属性值，若子属性还是对象则无法冻结，可循环深冻结\r\n\r\nObject.isExtensible(obj)：判断对象是否可扩展\r\nObject.isSealed(obj)：判断对象是否可配置\r\nObject.isFrozen(obj)：判断对象是否被冻结\r\n!!\r\n\r\n## 实例方法\r\n\r\n以下方法前面省略·Object.prototype.·\r\n\r\n!!\r\nvalueOf()：返回对象的原始值，默认返回对象本身，主要用于自动类型转换时调用\r\ntoString()：返回对象的字符串形式，即·\"[object Object]\"·，不同类型返回对应的值\r\ntoLocaleString()：和·toString()·返回的结果相同，作用是方便自定义，例如·Date·对象就自定义过\r\n\r\nisPrototypeOf()：判断当前对象是否为另一个对象的原型\r\nhasOwnProperty(key)：判断对象是否有某属性，只能判断自身的属性，继承的属性只会返回·false·\r\npropertyIsEnumerable()：判断某个属性是否可遍历，只能判断自身的属性，继承的属性只会返回·false·\r\n!!\r\n\r\n## es6\r\n\r\n### 属性\r\n\r\n!!\r\n__proto__：用来读取或设置当前对象的·prototype·对象\r\n    前后的双下划线说明它本质上是一个内部属性，并从兼容性考虑，所以尽量不直接操作这个属性\r\n    可使用·Object.setPrototypeOf()·、·Object.getPrototypeOf()·、·Object.create()·组合代替\r\n!!\r\n\r\n### 静态方法\r\n\r\n!!\r\nObject.is(a, b)：比较两个值是否相等，和·===·类似，还包括可以比较·NaN·、·-0·不等于·+0·或·0·\r\nObject.assign(target, ...source)：将源对象复制到目标对象，若有同名属性则后面覆盖前面\r\nObject.getOwnPropertyDescriptors(obj)：返回对象上所有属性的描述对象\r\nObject.setPrototypeOf(obj, proto)：设置一个对象的·prototype·对象，返回参数对象本身\r\nObject.values()：返回对象的键值组成的数组，只返回可遍历的属性\r\nObject.entries()：返回对象的键值对数组组成的数组，只返回可遍历的属性\r\nObject.fromEntries()：将一个键值对数组转为对象，即·Object.entries()·的逆操作\r\n!!\r\n\r\n### 属性简写\r\n\r\n若属性和变量名相同则可简写成一个：\r\n\r\n··js\r\nconst foo = 'abc'\r\nconst obj = { foo }\r\n// 等同于\r\nconst obj = { foo: foo }\r\n··\r\n\r\n方法也可以简写：\r\n\r\n··js\r\nconst o = {\r\n    method () {\r\n        return \"Hello!\"\r\n    }\r\n}\r\n// 等同于\r\nconst o = {\r\n    method: function () {\r\n        return \"Hello!\"\r\n    }\r\n}\r\n··\r\n\r\n### 属性表达式\r\n\r\n可使用方括号将属性名定义变量：\r\n\r\n··js\r\nlet propKey = 'foo'\r\n\r\nlet obj = {\r\n    [propKey]: true,\r\n    ['a' + 'bc']: 123\r\n}\r\n··\r\n\r\n还可用于方法名的简写：\r\n\r\n··js\r\nlet obj = {\r\n    ['h' + 'ello'] () {\r\n        return 'hi'\r\n    }\r\n}\r\n··\r\n\r\n但不能用于属性的简写，否则报错：\r\n\r\n··js\r\nconst baz = { [foo] } // 报错\r\n··\r\n\r\n注意，若属性名表达式返回的是对象则会转换成字符串\r\n\r\n### 方法的 name 属性\r\n\r\n函数的·name·属性返回函数名。对象方法也是函数，也有·name·属性：\r\n若是取值函数（getter）和存值函数（setter），则·name·属性不在该方法上，而在属性的描述对象的·get·和·set·属性上：\r\n\r\n··js\r\nconst obj = {\r\n    get foo() {},\r\n    set foo(x) {}\r\n}\r\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo')\r\ndescriptor.get.name // \"get foo\"\r\ndescriptor.set.name // \"set foo\"\r\n··\r\n\r\n·Function·构造函数创造的函数，·name·属性返回·anonymous·\r\n\r\n··js\r\n(new Function()).name // \"anonymous\"\r\n··\r\n\r\n·bind·方法创造的函数，·name·属性返回·bound·加上原函数的名字\r\n\r\n··js\r\nconst doSomething = function () {}\r\ndoSomething.bind().name // \"bound doSomething\"\r\n··\r\n\r\n如果对象的方法是·Symbol·值则返回这个·Symbol·值的描述\r\n\r\n··js\r\nconst key = Symbol('description')\r\nlet obj = {\r\n    [key] () {},\r\n}\r\nobj[key].name // \"[description]\"\r\n··\r\n\r\n### super\r\n\r\n·this·总是指向函数所在的当前对象，而·super·指向当前对象的原型对象，且只能用在对象的**简写**方法之中\r\n\r\n··js\r\nconst obj = {\r\n    name: '张三',\r\n    getName: function () {\r\n        console.log(this.name)\r\n    }\r\n}\r\nobj.getName() // 张三\r\n··\r\n\r\n··js\r\nconst obj = {\r\n    foo: 'world',\r\n    find () {\r\n        console.log(super.foo)\r\n    }\r\n}\r\nconst proto = {\r\n    foo: 'hello'\r\n}\r\n\r\nobj.find() // undefined\r\nobj.__proto__ = proto\r\nobj.find() // \"hello\"\r\n··\r\n\r\n以下写法错误：\r\n\r\n··js\r\n// 不能用于属性\r\nconst obj = {\r\n  foo: super.foo\r\n}\r\n\r\n// 不是属性方法的简写形式\r\nconst foo = {\r\n    foo: () => super.foo\r\n}\r\nconst bar = {\r\n    bar: function () {\r\n        return super.bar\r\n    }\r\n}\r\n··\r\n\r\n其实·super.foo·等同于·Object.getPrototypeOf(this).foo·\r\n或·super.foo()·等同于·Object.getPrototypeOf(this).foo.call(this)·\r\n\r\n### 扩展运算符\r\n\r\n扩展运算符·...·可取出对象的所有可遍历属性，并需要对象容器包裹\r\n\r\n#### 解构赋值\r\n\r\n将剩余的值拷贝到新对象上\r\n\r\n··js\r\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }\r\nx // 1\r\ny // 2\r\nz // { a: 3, b: 4 }\r\n··\r\n\r\n#### 拷贝对象\r\n\r\n空对象和除了字符串以外的类型将没有效果\r\n\r\n··js\r\nlet z = { a: 3, b: 4 }\r\nlet n = { ...z }\r\nn // { a: 3, b: 4 }\r\n\r\nlet foo = { ...['a', 'b', 'c'] }\r\nfoo // {0: \"a\", 1: \"b\", 2: \"c\"}\r\n\r\n{...'hello'} // {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\r\n··\r\n\r\n等同于使用·Object.assign()·：\r\n\r\n··js\r\nlet aClone = { ...a }\r\n// 等同于\r\nlet aClone = Object.assign({}, a)\r\n··\r\n\r\n可以用于合并两个对象，若有相同属性则后面覆盖前面：\r\n\r\n··js\r\nlet ab = { ...a, ...b }\r\nlet axy = { ...a, x: 1, y: 2 }\r\n··\r\n\r\n扩展运算符后面可以跟表达式：\r\n\r\n··js\r\nconst obj = {\r\n  ...(x > 1 ? {a: 1} : {}),\r\n  b: 2\r\n}\r\n··\r\n\r\n&2019/08/03\r\n            `\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./object.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./object.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./object.vue?vue&type=template&id=565c4317&\"\nimport script from \"./object.vue?vue&type=script&lang=js&\"\nexport * from \"./object.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}