(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0def22"],{"888d":function(n,e,o){"use strict";o.r(e);var s=function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{domProps:{innerHTML:n._s(n.format(n.text))}})},t=[],c={data:function(){return{text:"\n# 网络请求\n\n## WebSocket\n\n### 介绍\n\nHTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息\n例如聊天室，如果服务器有连续的状态变化，客户端要获知就非常麻烦，只能使用轮询或长连接\nWebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了\n最大的特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，它们之间存着一条持续打开的数据通道\n其他特点：\n\n!!\n建立在 TCP 协议之上，服务器端的实现比较容易\n与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443\n数据格式比较轻量，性能开销小，通信高效\n可以发送文本，也可以发送二进制数据\n没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax\n协议标识符是·ws·（如果加密，则为·wss·，对应 HTTPS 协议），服务器网址就是 URL\n!!\n\n### 握手请求\n\n浏览器发出的 WebSocket 握手请求形如：\n\n··js\nGET / HTTP/1.1\nConnection: Upgrade // 浏览器通知服务器升级到 WebSocket 协议\nUpgrade: websocket // 将通信协议从 HTTP/1.1 转向该字段指定的协议\nHost: example.com\nOrigin: null // 发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== // 握手协议的密钥，是 Base64 编码的16字节随机字符串\nSec-WebSocket-Version: 13\n··\n\n服务器的 WebSocket 回应形如：\n\n··js\nHTTP/1.1 101 Switching Protocols\nConnection: Upgrade\nUpgrade: websocket\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\nSec-WebSocket-Origin: null\nSec-WebSocket-Location: ws://example.com/\n··\n\n### API\n\n浏览器对 WebSocket 协议的处理就是三件事：建立和断开连接、发送和接收数据、处理错误\n\n!!\nnew WebSocket(url, [protocols])：新建 WebSocket 实例，让客户端与服务器进行连接\n    url{s}：要连接的 url，使用·ws·或·wss·协议\n    protocols {String/Array}：指定子协议，让单个服务器可以实现多个 WebSocket 子协议\n\nws.readyState：实例对象的当前状态，可能的值：\n    WebSocket.CONNECTING [0]：表示正在连接\n    WebSocket.OPEN [1]：表示连接成功，可以通信了\n    WebSocket.CLOSING [2]：表示连接正在关闭\n    WebSocket.CLOSED [3]：表示连接已经关闭，或者打开连接失败\nws.binaryType：指定接收的二进制数据类型，可指定的类型：\n    blob：收到的是 blob 数据\n    arraybuffer：收到的是 ArrayBuffer 数据\nws.bufferedAmount：还未发送出去的二进制数据，可以用来判断发送是否结束\nws.extensions：服务器已选择的扩展值，目前链接可以协定的扩展值只有空字符串或者一个扩展列表\nws.protocol：服务器端选中的子协议名称\nws.url：实例对象的 url\n\nws.send(data)：向服务器发送数据，·data·接受的类型：\n    <String>：文本字符串\n    <Blob>：二进制大对象\n    <ArrayBuffer>：二进制数据\n    <ArrayBufferView>：二进制帧\nws.close([code, reason])：关闭当前连接\n    code [1005]：指定关闭的状态码，详见[状态码列表](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes)\n    reason：说明连接关闭的原因，长度不能超过 123 个字节\n\nws.onopen：连接成功时触发\nws.onclose：连接关闭时触发\nws.onmessage：收到服务器数据时触发\nws.onerror：报错时的回调函数\n!!\n\n示例：\n\n··js\nlet ws = new WebSocket('wss://www.websocket.com/ws')\n\nws.addEventListener('open', res => {\n    console.log('连接成功')\n    console.log(res)\n})\nws.addEventListener('message', res => {\n    console.log('连接成功')\n    console.log(res)\n})\nws.addEventListener('close', res => {\n    console.log('已关闭连接')\n    console.log(res)\n})\nws.addEventListener('error', res => {\n    console.log('连接错误')\n    console.log(res)\n})\n$sendBtn.addEventListener('click', e => {\n    ws.send('hello')\n})\n$closeBtn.addEventListener('click', e => {\n    ws.close()\n})\n··\n\n@@\n[socket.io](https://socket.io)\n@@\n\n&2019/10/23\n"}}},r=c,l=o("2877"),a=Object(l["a"])(r,s,t,!1,null,null,null);e["default"]=a.exports}}]);
//# sourceMappingURL=chunk-2d0def22.7e871df7.js.map