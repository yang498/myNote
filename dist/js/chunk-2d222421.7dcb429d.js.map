{"version":3,"sources":["webpack:///./src/pages/article/jsLib/jquery.vue?3cff","webpack:///src/pages/article/jsLib/jquery.vue","webpack:///./src/pages/article/jsLib/jquery.vue?bcd9","webpack:///./src/pages/article/jsLib/jquery.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,uu+BCR8W,I,YCO1WC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d222421.7dcb429d.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# jQuery\r\n\r\n本文档记录版本·v3.2.1·\r\n\r\n## 概述\r\n\r\njQuery 就是把 javascript 一些常用的功能和兼容性问题进行了封装\r\n引入 jQuery 会提供 2 个全局变量：·jQuery·，和简写·$·\r\n链接引入：\r\n\r\n··html\r\n<script src=\"https://unpkg.com/jquery@3.2.1/dist/jquery.js\">&lt;/script>\r\n<script src=\"https://unpkg.com/jquery@3.2.1/dist/jquery.min.js\">&lt;/script>\r\n··\r\n\r\nnpm 安装：\r\n\r\n··bash\r\nnpm i jquery\r\n··\r\n\r\n## css 选择器\r\n\r\n使用·$()·可以用来选择 DOM 元素，用法和 CSS 类似，并做了些扩展\r\n\r\n### 基本\r\n\r\n!!\r\n*：所有元素\r\nelement：元素名\r\n.class：样式名\r\n#id：id 名，如果有多个相同 id 的元素只返回第一个\r\nselector, selectorN：多选\r\n$.escapeSelector(selector)：转义选择器中的关键字·. # , : [ ] = @·\r\n!!\r\n\r\n#### $.escapeSelector(selector)\r\n\r\n例如获取·id=\"#demo.text\"·，则·$('##demo.text')·是无效的，应改成·$('#' + $.escapeSelector('#demo.text'))·\r\n也可以直接使用斜杠转义：·$('#\\\\\\\\#demo\\\\\\\\.text')·，或自定义加斜杠：\r\n\r\n··js\r\nfunction jq (selector) {\r\n    return selector.replace(/[:\\\\.\\\\[\\\\],=@]/g, '\\\\\\\\$&')\r\n}\r\n$('#' + jq('#demo.text'))\r\n··\r\n\r\n### 层级\r\n\r\n!!\r\nparent > child：子元素，所有子元素为·parent >·\r\nancestor descendant：后代元素，所有后代元素为·ancestor *·\r\nprev + next：下一个指定元素，所有紧邻元素为·prev +·\r\nprev ~ siblings：后面所有指定的元素，后面所有的元素为·prev ~·\r\n!!\r\n\r\n### 属性\r\n\r\n单个属性值的引号是可选的，即·[attr=value]·和·[attr=\"value\"]·相等\r\n多个属性值时就必须用引号了，比如·[attr=val1 val2]·会报错，需加上引号·[attr=\"val1 val2\"]·\r\n且多个属性值的顺序也是不能变的，即匹配的是整个字符串\r\n\r\n!!\r\n\\\\[attr]：指定属性，如·$('[class]')·\r\n\\\\[attr=\"value\"]：属性只等于该值，如·$('[class=\"demo\"]')·\r\n\\\\[attr!=\"value\"]：属性不等于该值，如·$('[class!=\"demo\"]')·\r\n\\\\[attr*=\"value\"]：含有指定字符串，如·$('[class*=\"acti\"]')·\r\n\\\\[attr~=\"value\"]：含有指定单词，如·$('[class*=\"active\"]')·\r\n\\\\[attr^=\"value\"]：以指定字符串开头的属性，如·$('[class^=\"text-\"]')·\r\n\\\\[attr$=\"value\"]：以指定字符串结尾的属性，如·$('[class$=\"-text\"]')·\r\n\\\\[attr|=\"value\"]：正好是·value·或以·value-·开头的属性\r\n    如·$('a[hreflang|=\"en\"]')·选择·hreflang=\"en\"·或·hreflang=\"en-UK\"·，不会选择·hreflang=\"english\"·\r\n!!\r\n\r\n### 子元素\r\n\r\n!!\r\n:first-child：第一个，如·$('li:first-child')·\r\n:last-child：最后一个，和·:first-child·相反\r\n:first-of-type：第一个，和·:first-child·的区别在于·$('li:first-child')·若 li 不是第一个子元素也可以获取\r\n:last-of-type：最后一个，和·:first-of-type·相反\r\n:nth-child(index/odd/even/equation)：根据条件选择\r\n:nth-last-child(index/even/odd/equation)：·:nth-child()·的倒数版\r\n:nth-of-type(index/even/odd/equation)：和·:nth-child()·不同的是会忽略其他不同的元素\r\n:nth-last-of-type(index/even/odd/equation)：·:nth-of-type()·的倒数版\r\n:only-child：如果某个元素是其父元素的唯一子元素，那么它就会被选中\r\n:only-of-type：和·:only-child·不同的是会忽略其他不同的元素\r\n!!\r\n\r\n#### :nth-child(index/odd/even/equation)\r\n\r\n·index·从 1 开始且不能为负数，可以是字符串·odd·奇数或·even·偶数，也可以是 n 倍如·4n·\r\n\r\n··html\r\n<ul>\r\n    <li>A</li>\r\n    <li>B</li>\r\n    <li>C</li>\r\n    <li>D</li>\r\n</ul>\r\n<ul>\r\n    <p>P</p>\r\n    <li>E</li>\r\n    <li>F</li>\r\n    <li>G</li>\r\n    <li>H</li>\r\n</ul>\r\n\r\n<script>\r\n    $('li:nth-child(1)')    // A （必须是父元素的第一个子元素，所以没有 E）\r\n    $('li:nth-child(2)')    // B E\r\n    $('li:nth-child(odd)')  // A C F H\r\n    $('li:nth-child(even)') // B D E G\r\n    $('li:nth-child(4n)')   // D G\r\n&lt;/script>\r\n··\r\n\r\n### 集合筛选\r\n\r\n!!\r\n:eq(index)：第·index·个，·index·可以为负数表示倒数，如·$('li:eq(2)')·表示在所有的·li·元素中选择第 3 个\r\n:first：第一个，比如·$('li:first')·\r\n:last：最后一个，比如·$('li:last')·\r\n:gt(index)：下标大于给定·index·的元素，比如·$('li:gt(2)')·\r\n:lt(index)：下标小于给定·index·的元素，和·:gt(index)·相反\r\n:odd：下标为奇数，即 1 3 5 7 9...，比如·$('li:odd')·\r\n:even：下标为偶数，即 0 2 4 6 8...，比如·$('li:even')·\r\n!!\r\n\r\n### 内容筛选\r\n\r\n!!\r\n:not(selector)：除了指定的元素\r\n:has(selector)：后代元素中包含指定元素的元素，根据匹配结果的·length·可判断是否包含某元素\r\n:contains(text)：后代元素中包含指定文本的元素，·text·可加可不加引号\r\n:empty：没有子元素的元素，有空格也不行，即空标签\r\n:parent：非空标签，和·:empty·相反\r\n:hidden：隐藏的元素，包括其隐藏的后代元素，即·display:none·、·type=\"hidden\"·、·head style script·等\r\n:visible：未隐藏的元素，和·:hidden·相反\r\n!!\r\n\r\n### 其他筛选\r\n\r\n!!\r\n:lang(language)：指定语言，如·$(':lang(en)')·选择·lang=\"en\"/lang=\"en-us\"·\r\n:animated：正在执行 jQuery 动画的元素，如正在执行·fadeToggle()·动画，就能被·$(':animated')·获取到\r\n:target：·id·和当前·hash·值相同的元素，如网址是·xxx.com/#foo·，则·$(\":target\")·将匹配·<h1 id=\"foo\">·\r\n:header：所有标题，即·$('h1, h2, h3, h4, h4, h6')·\r\n:root：根元素，即·$('html')·\r\n!!\r\n\r\n### 表单筛选\r\n\r\n!!\r\n:input：表单元素，即·$('input, textarea, select, button')·\r\n:text：文本类型元素，若·<input/>·无 type 属性（默认为 text）则·$('[type=\"text\"]')·获取不到，而·:text·可以\r\n:password：密码类型元素，即·$('[type=\"password\"]')·\r\n:radio：单选类型元素，即·$('[type=\"radio\"]')·\r\n:checkbox：多选类型元素，即·$('[type=\"checkbox\"]')·\r\n:file：文件类型元素，即·$('[type=\"file\"]')·\r\n:image：图片类型元素，即·$('[type=\"image\"]')·\r\n:button：按钮类型元素，即·$('button, [type=\"button\"]')·\r\n:submit：提交类型元素，即·$('[type=\"submit\"]')·\r\n:reset：重置类型元素，即·$('[type=\"reset\"]')·\r\n:checked：选中的元素，适用·<checkbox> <radio> <option>·\r\n:selected：选中的元素，适用·<option>·\r\n:disabled：禁用的元素，即·$('[disabled]')·\r\n:enabled：未禁用的元素，即·$(':not([disabled])')·\r\n:focus：已获取焦点的元素，适用于表单元素和·a·标签\r\n!!\r\n\r\n## 方法选择器\r\n\r\n### 筛选\r\n\r\n!!\r\n.eq(index)：第 index 个，index 可以为负数表示倒数\r\n.first()：第一个\r\n.last()：最后一个\r\n.not(selector/function(index))：除了给定选择器或函数返回值的元素\r\n.has(selector)：后代元素中包含指定·selector·的元素，根据匹配结果的length可判断是否包含某元素\r\n$.contains(parent, child)：判断一个元素是否包含另一个元素，必须都是原生元素，不支持文本和注释节点\r\n.filter(selector/function(index))：筛选出指定元素，可以是选择器或函数，函数的用法同数组的·filter·\r\n$.grep(array, function(item, index) [, invert])：筛选元素或数组\r\n    ·invert·默认为·false·，若为·true·将返回和筛选条件相反的元素\r\n.slice(start [, end])：截取指定下标内的元素，用法同数组的·slice·\r\n!!\r\n\r\n\r\n### 子元素\r\n\r\n!!\r\n.children()：子元素，不包括文字和注释节点\r\n.contents()：子元素，包扩文本和注释节点，·<iframe>·内的元素也可获取（跨域无法访问）\r\n!!\r\n\r\n### 父元素\r\n\r\n!!\r\n.parent([selector])：父级元素，可以传入一个参数 selector 以筛选获得的父元素\r\n.parents([selector])：所有祖先元素，可以传入一个参数 selector 以筛选获得的父元素\r\n.parentsUntil([selector/element] [, selector])：所有祖先元素直到第一个参数为止，第二个参数可以进行筛选\r\n!!\r\n\r\n### 兄弟元素\r\n\r\n!!\r\n.prev([selector])：前一个，可以传入一个参数 selector 以筛选获得的兄弟元素\r\n.next([selector])：后一个，和·.prev()·相反\r\n.prevAll([selector])：前面所有，用法同·.prev()·\r\n.nextAll([selector])：后面所有，和·.prevAll()·相反\r\n.siblings([selector])：前后所有，即·.prevAll()·和·.nextAll()·加起来\r\n.prevUntil([selector/element] [, selector])：前面直到哪里，可以传入第二个参数进行筛选\r\n.nextUntil([selector/element] [, selector])：后面直到哪里，和·.prevUntil()·相反\r\n!!\r\n\r\n### 查找\r\n\r\n!!\r\n.find(selector/element)：往下找，在所有子孙元素中找到匹配的元素\r\n.closest(selector/element [, element])：往上找，可以传入第二个参数限定范围（原生元素）\r\n!!\r\n\r\n### 判断\r\n\r\n!!\r\n.is(selector/function(index))：判断若能根据选择器至少找到 1 个则返回·true·，否则·false·\r\n    可以传入一个函数，返回的 Boolean 值直接作为结果\r\n!!\r\n\r\n## DOM 属性\r\n\r\n### css\r\n\r\n!!\r\n.addClass(class/fn(index, class))：添加 class，多个样式名以空格隔开\r\n.removeClass(class/fn(index, class))：删除 class，多个样式名以空格隔开，没有参数将全部移除\r\n.toggleClass(class/fn(index, class) [, state])：切换 class，多个样式名以空格隔开，没有参数将全部切换\r\n    state [Boolean]：指定是添加还是删除样式\r\n.hasClass(class)：是否含有 class，可以传入·''·判断有没有类名\r\n.css()：获取或设置样式\r\n$.cssHooks：扩展·.css()·\r\n$.cssNumber：在用·.css()·设置数值时哪些属性不用加 px，例如·$.cssNumber.left = true·\r\n!!\r\n\r\n#### .css(className/classNameArr [, value/function])\r\n\r\n获取或设置样式，2 个单词以上的属性名可以使用连字符或驼峰法，如·background-color·和·backgroundColor·\r\n\r\n··js\r\n// 获取属性值\r\n$('.demo').css('color')\r\n// 获取多个属性值，返回属性名和属性值组成的对象\r\n$('.demo').css(['color', 'background-color', 'font-size'])\r\n\r\n// 设置属性值\r\n$('.demo').css('color', '#f00')\r\n// 设置多个属性值\r\n$('.demo').css({\r\n    'color': '#f00',\r\n    'font-size': '20px'\r\n})\r\n\r\n// 若设置的值为数字，将会转换为字符串并添加 px\r\n$('.demo').css('width', 50)\r\n// 只有部分值支持设置字符串数字补全 px，具体可打印 $.cssHooks 查看，一般带 set 的有字符串补全\r\n$('.demo').css('left', '50') // left: ''\r\n$.cssHooks.left = {\r\n    get: $.cssHooks.left.get,\r\n    set: function (el, value) {\r\n        el.style.left = /^\\\\d+$/.test(value) ? value + 'px' : value\r\n    }\r\n}\r\n$('div').css('left', '50') // left: '50px'\r\n\r\n// 若设置的值为空字符串，如果行内 style 中有这个属性将会移除\r\n$('.demo').css('color', '')\r\n// 设置相对值可使用以 += 或者 -= 开头的字符串，即在原来的基础上进行增减\r\n$('.demo').css('padding-left', '+=20')\r\n// 设置一个函数，返回值即为要设置的值\r\n$('.demo').css('width', function (index, style) {\r\n    return '100px'\r\n})\r\n··\r\n\r\n### 属性\r\n\r\n!!\r\n.val([value/function])：获取或设置 value 值\r\n.attr(name [, value/function])：获取或设置属性值，若设置多个值可传入对象，用法同·.css()·\r\n.removeAttr(name)：删除属性值，多个属性可使用空格隔开\r\n.prop()：获取或设置 Boolean 值的属性，如·disabled, checked·，用法同·.attr()·\r\n.removeProp()：删除属性值，多个属性可使用空格隔开\r\n    注意删除原生的属性如·disabled·将完全移除该属性，不能再次被添加到元素上\r\n!!\r\n\r\n### 数据\r\n\r\n!!\r\n.data([key] [, value])：在元素上读取或存储以·data-·开头的属性数据\r\n.removeData([name])：删除数据，不传入参数表示全部删除，删除多个可传入以空格隔开的字符串或字符串数组\r\n$.data()：.data() 的另一种写法，原生元素作为第一个参数\r\n$.removeData()：.removeData() 的另一种写法，原生元素作为第一个参数\r\n$.hasData()：判断元素是否有 .data() 绑定的数据，原生元素作为参数\r\n!!\r\n\r\n#### .data([key] [, value])\r\n\r\n··js\r\n$('.demo').data('test-a', 'hhhh')   // 存储\r\n$('.demo').data()   // {testA: \"hhhh\"}\r\n\r\n// <div class=\"demo\" data-demo=\"demo\" data-test-a=\"hh\"></div>\r\n$('.demo').data()   // {demo: \"demo\", testA: \"hh\"}\r\n$('.demo').data('testA')    // \"hh\"\r\n$('.demo').data({'test-a': 'aaa', 'test-b': 'bbbb'})\r\n$('.demo').data()   // {demo: \"demo\", testA: \"aaa\", testB: \"bbbb\"}\r\n··\r\n\r\n### 尺寸\r\n\r\n!!\r\n.width([value/fn])：获取或设置宽度，不包括·padding border·\r\n.height([value/fn])：获取或设置高度，用法同·.width()·\r\n.innerWidth([value/fn])：获取或设置宽度，包括·padding·，不包括·border·，用法同上\r\n.innerHeight([value/fn])：获取或设置高度，用法同上\r\n.outerWidth([value/fn])：获取或设置宽度，包括·padding border·，可传入·true·表示包括·margin·，用法同上\r\n.outerHeight([value/fn])：获取或设置高度，用法同上\r\n!!\r\n\r\n### 位置\r\n\r\n!!\r\n.offset([obj/fn])：获取或设置相对于文档的·left top·\r\n.offsetParent()：获取离指定元素最近的非·static·定位的祖先元素\r\n.position()：返回一个对象，包含·left top·，坐标相对于离指定元素最近的非 static 定位的祖先元素\r\n.scrollTop([value])：获取或设置·scrollTop·，可传入数值以设置这个距离，例如设为 0 表示回到顶部\r\n.scrollLeft([value])：获取或设置·scrollLeft·，用法同·.scrollTop()·\r\n!!\r\n\r\n### 索引\r\n\r\n!!\r\n.index([el])：不传入参数表示获取元素在所有同级元素中的位置，若元素有多个则取第一个，若没有匹配元素返回·-1·\r\n    传入一个元素表示在匹配的元素中查找参数位置，如·$('div').index($('.demo'))·，相当于数组的·indexOf()·\r\n!!\r\n\r\n### 获取原生元素\r\n\r\n·$()·选择的是 jQuery 封装过的对象，像数组一样选择对应的下标即可获取原生元素，例如·$('.demo')[0]·\r\n\r\n!!\r\n.get([index])：获取指定下标的原生元素，·index·可以设置为负数表示倒数\r\n    若不传入参数·.get()·则获取所有原生元素组成的数组，即把 jQuery 元素转成原生元素\r\n.toArray()：等同于·.get()·\r\n$.makeArray($el)：等同于·.get()·\r\n!!\r\n\r\n## DOM 操作\r\n\r\n### 复制\r\n\r\n!!\r\n.clone([dataEvent] [, deep])：拷贝指定元素，包括子元素\r\ndataEvent {Boolean} [false]：是否将事件和·data-·属性也拷贝\r\ndeep {Boolean} [dataEvent]：是否所有后代元素也将事件和·data-·属性拷贝，默认和第一个参数保持一致\r\n!!\r\n\r\n··js\r\n$('.demo').clone().appendTo('.test')\r\n\r\n// 若元素未经复制就进行添加等操作表示移动该元素\r\n$('.demo').appendTo('.test') // $('.demo')被移动到$('.test')内部的末尾处\r\n··\r\n\r\n### 内部添加\r\n\r\n!!\r\n.text([text/fn])：获取或设置文本\r\n.html([html/fn])：获取或设置 html\r\n.append(...content/fn)：在元素里面的最后添加，例如·$('.demo').append($('i'), '<p></p>')·\r\n.appendTo(target)：写法和·.append()·相反，例如·$('<p></p>').appendTo('.demo')·\r\n.prepend(...content/fn)：在元素里面的开头添加，用法同·.append()·\r\n.prependTo(target)：写法和·.prepend()·相反\r\n!!\r\n\r\n### 外部添加\r\n\r\n!!\r\n.after(...content/fn)：在匹配元素的后面添加参数（作为兄弟节点），参数用法同·.append()·\r\n.before(...content/fn)：在元素前面添加，用法同·.after()·\r\n.insertAfter(target)：和·.after()·的写法相反，要添加的内容被添加到元素的后面\r\n.insertBefore(target)：和·.before()·的写法相反，要添加的内容被添加到元素的前面\r\n!!\r\n\r\n### 外部包裹\r\n\r\n!!\r\n.wrap(el/fn)：为每个元素添加父元素，传入多个元素只使用第一个，传入多层元素保留只使用最里面的第一个子元素\r\n.wrapAll(el/fn)：为所有的元素添加一个父元素，若中间有其他元素会被排除，多个元素或多层元素效果同·.wrap()·\r\n.wrapInner(el/fn)：为每个元素的内部添加父元素，多个元素或多层元素效果同·.wrap()·\r\n.unwrap([selector])：为每个元素删除父元素，和 .wrap() 相反，可传入选择器在筛选哪些元素的父元素应该被删除\r\n!!\r\n\r\n### 删除\r\n\r\n!!\r\n.remove([selector])：删除元素和其后代，包括绑定的事件和·.data()·绑定的数据，可传入选择器筛选哪些被删除\r\n.detach()：删除元素和其后代，保留绑定的事件和·.data()·绑定的数据，适用于把元素删除之后再添加到页面中\r\n.empty()：删除元素的后代，即把元素变成空标签\r\n!!\r\n\r\n### 替换\r\n\r\n!!\r\n.replaceWith(newContent/function)：将元素替换成指定元素\r\n.replaceAll(target)：和·.replaceWith()·写法相反，指定元素把目标元素替换\r\n!!\r\n\r\n## DOM 状态\r\n\r\n### 追加\r\n\r\n!!\r\n.add(selector/html [, context])：在已选择的元素中追加指定元素，可选择第二个参数筛选要追加的元素\r\n.addBack()：在已选择的元素中追加前一个选择的元素，如·$('.demo').nextAll().addBack()·\r\n.pushStack(el, name, args)：生成新的 jQuery 对象，常用于链式调用中\r\n!!\r\n\r\n### 回退\r\n\r\n!!\r\n.end()：返回元素的上一次状态，通常用于链式调用中\r\n!!\r\n\r\n### DOM 遍历\r\n\r\n!!\r\n.each(function(index, item))：循环元素并执行函数，·this·即当前原生元素，使用·return false·可结束循环\r\n$.each(jQueryDOM/array/object, function(index, item))：和·.each()·类似，还可以遍历数组和对象\r\n.map(function(index, item))：在函数内部返回新的值以生成新的 jQuery 对象\r\n$.map(jQueryDOM/array/object, function(item, index))：和·.map()·类似，，还可以遍历数组和对象\r\n!!\r\n\r\n## 事件\r\n\r\n### .on()\r\n\r\n绑定事件：·.on(events [, selector] [, data], handler(eventObject))·\r\n\r\n!!\r\nevents {String}：事件类型，可添加一个或多个命名空间例如·click.demo·，相当于元素的 class\r\nselector {String}：触发事件的元素为指定后代元素，即事件代理，常用于变动的后代元素，可选择不填或填写·null·\r\ndata：事件触发时传递给回调函数的·event.data·，若是字符串类型则必须传入·selector·，不然会被当做·selector·\r\nhandler {Function}：事件触发时执行的函数\r\n!!\r\n所有以事件名为方法名的方法都是该事件的快捷写法，注意简写的方式没有事件代理\r\n例如·.click([data,] handler(eventObject))·等同于·.on('click', [data,] handler(eventObject))·\r\n快捷写法支持的事件包括：\r\n!!\r\n**鼠标**\r\n    click：左键点击\r\n    contextmenu：右键点击\r\n    dblclick：左键双击\r\n    mousedown：左键或右键按下\r\n    mouseup：左键或右键松开\r\n    mouseover：当指针覆盖元素时（冒泡）\r\n    mouseout：当指针离开元素时（冒泡）\r\n    mouseenter：当指针覆盖元素时（不冒泡）\r\n    mouseleave：当指针离开元素时（不冒泡）\r\n    hover(fn(e), fn(e))：当指针覆盖和离开时，等同于·.mouseenter(fn(e)).mouseleave(fn(e))·\r\n\r\n**键盘**\r\n    keydown：按下按键时，如果不抬起来会一直触发（·<input>·和·<textarea>·元素中）\r\n    keyup：松开按键时（·<input>·和·<textarea>·元素中）\r\n    keypress：按下按键时，不抬起来也只触发一次（·<input>·和·<textarea>·元素中）\r\n\r\n**表单**\r\n    focus：获得焦点（不冒泡），设置 tabindex 属性也可获得焦点\r\n    blur：失去焦点（不冒泡）\r\n    focusin：获得焦点（冒泡）\r\n    focusout：失去焦点（冒泡）\r\n    select：选中完文本时（·<input>·和·<textarea>·元素中）\r\n    change：元素的值改变的时\r\n\r\n**浏览器**\r\n    scroll：页面滚动时触发（在·$(window)·或滚动容器上绑定）\r\n    resize：当浏览器的尺寸改变（在·$(window)·上绑定 ）\r\n        不同浏览器略有不同，例如 Chrome 是改变时持续调用，Opera 在改变后调用\r\n\r\n**文档加载**\r\n    ready：写法·$(fn)·，当文档准备就绪时\r\n        其他写法都已弃用，例如·$(document).on('ready', fn)·，实际上·$(document)·什么也没选择\r\n    $.holdReady(Boolean)：是否不触发·ready·事件，即用来延迟·ready·事件\r\n        例如先执行·$.holdReady(true)·，后续不会触发·$(fn)·，需再执行·$.holdReady(false)·才触发·$(fn)·\r\n!!\r\n\r\n### .off()\r\n\r\n移除事件：·.off([events] [, selector ] [, handler ])·\r\n\r\n!!\r\nevents：一个或多个空格分隔的事件类型和可选的命名空间，或只有命名空间\r\nselector：事件代理的元素\r\nhandler：要移除的事件方法（一个事件可绑定多个方法）\r\n!!\r\n\r\n### .one()\r\n\r\n用法同·.on()·，事件只会触发一次\r\n\r\n### .trigger()\r\n\r\n手动触发事件：·.trigger(event [, extraParameters])·\r\n通过·.on()·或快捷方式绑定的事件可以用·.trigger()·手动触发\r\n以事件名为调用的方法都是该事件的快捷写法，例如·.click()·等同于·.trigger('click')·\r\n\r\n!!\r\nevent {String/$.Event}：事件类型的字符串或 jQuery 的事件对象\r\nextraParameters {Array/Object}：传递给事件函数的参数\r\n!!\r\n\r\n··\r\n$('#btn1').click(function (e, a, b) {\r\n    console.log(e, a, b)\r\n})\r\n\r\n// 点击 btn2 同时触发 btn1\r\n$('#btn2').click(function () {\r\n    console.log('222')\r\n    $('#btn1').click(['aaa', 'bbb'])\r\n})\r\n··\r\n\r\n### .triggerHandler()\r\n\r\n用法同·.trigger()·，不同之处有：\r\n\r\n!!\r\n·triggerHandler·不触发默认事件，例如表单提交·submit·\r\n·triggerHandler·只触发第一个匹配到的元素，·trigger·会触发所有匹配的元素\r\n·triggerHandler·触发的函数不冒泡\r\n!!\r\n\r\n### 事件对象\r\n\r\n注意，jQuery 的事件对象重定义过，所以一些特殊属性例如拖拽事件产生的·e.dataTransfer·属性是没有的，需改回原生事件监听\r\n\r\n!!\r\ncurrentTarget：调用事件的对象，一般情况下等同于·this·（前提没有使用箭头函数或改变了·this·的指向）\r\ntarget：触发事件的元素，可以是元素本身或子元素冒泡触发的子元素，通常同于和·this·比较是否冒泡了\r\ndata：传递的参数\r\ntype：事件的类型\r\nnamespace：当前事件的命名空间\r\nwhich：键盘和鼠标事件中的键盘码（[参考对照表](http://www.t086.com/article/4315)）或鼠标码（左键 1，中建 2，右键 3）\r\nresult：事件的返回值，例如事件绑定了 2 个函数，第一个函数中返回了一个字符串，第二个函数将可以接收到\r\nrelatedTarget：事件涉及的元素，例如·mouseover·是从哪个元素进来的，·mouseout·是离开到最近的那个元素\r\npageX：鼠标相对于当前文档左侧的距离，包括滚动的距离\r\npageY：鼠标相对于当前文档顶部的距离，包括滚动的距离\r\ntimeStamp：事件触发时的时间戳\r\n\r\npreventDefault()：阻止默认行为，例如点击·<a>·会跳转到对应的链接，调用此方法后不会跳转\r\nstopPropagation()：阻止事件的冒泡行为\r\nstopImmediatePropagation()：阻止其它的事件执行和冒泡行为，例如事件绑定了 2 个函数将只触发第一个\r\nisDefaultPrevented()：返回 Boolean 值，检测·event.preventDefault()·是否被调用过\r\nisPropagationStopped()：返回 Boolean 值，检测·event.stopPropagation()·是否被调用过\r\nisImmediatePropagationStopped()：返回 Boolean 值，检测·event.stopImmediatePropagation()·是否被调用过\r\n!!\r\n\r\n## 过渡动画\r\n\r\n### 显示隐藏\r\n\r\n!!\r\n.hide()：隐藏元素\r\n.show()：显示元素，和·.hide()·相反，用法同·.hide()·\r\n.toggle()：如果元素显示就隐藏，隐藏就显示，用法同·.hide()·，多了可传入一个 Boolean 值指定显示或隐藏元素\r\n!!\r\n\r\n#### .hide()\r\n\r\n隐藏元素，直接使用·.hide()·没有动画，相当于·.css('display', 'none')·\r\n\r\n**传入多个参数：**·.hide([duration] [, easing] [, complete])·\r\n\r\n!!\r\nduration {Number/String} [400]：动画持续时间，单位 ms，可填字符串·normal(400) fast(200) slow(600)·\r\neasing {String} [swing]：运动曲线，可选·swing·(类似·ease·) 或·linear·，其他需使用插件如 [jQuery Easing](http://gsgd.co.uk/sandbox/jquery/easing/)\r\ncomplete {Function}：动画完成时执行的函数\r\n!!\r\n\r\n3 个参数都是单独可选的，但传入一个参数也表示启用其他默认参数，例如传入函数将默认启用了·duration·和·easing·\r\n动画改变的是：·width height opacity· 直到 0，然后设置·display:none;·\r\n如果是·display:inline;·的元素将会在动画中暂时变成·display:inline-block;·，因为这样才能改变·width height·\r\n\r\n**传入一个 Object：**·.hide(options)·\r\n\r\n!!\r\nduration {Number/String} [400]：动画持续时间，同上\r\neasing {String} [swing]：运动曲线，同上\r\nqueue {Boolean/String} [true]：是否将动画放置在效果队列中\r\n    设为·true/false·将立即开始动画\r\n    设为字符串表示为该动画队列加上名称，动画不会启动，需调用·.dequeue('queuename')·才会启动\r\nspecialEasing {Object}：分别为属性定义运动曲线，例如·{ width: 'linear', height: 'swing' }·\r\nstep {Function(now, tween)}：每个动画元素的每个动画属性在每帧调用的函数\r\n    now {Number}：当前帧的属性值\r\n    tween {Object}：当前帧的属性\r\n        easing {String}：当前属性应用的运动曲线\r\n        elem {Element}：当前动画的元素\r\n        prop {String}：当前动画的 css 属性名\r\n        start {Number}：当前动画的起始值\r\n        end {Number}：当前动画的目标值\r\n        now {Number}：当前动画的当前值\r\n        pos {Number}：1\r\n        unit {String}：属性单位\r\n        options {Object}：其他属性，例如·duration·和·queue·\r\nprogress {Function(animation, progress, remainingMs)}：每帧动画完成后调用的一个函数\r\n    animation {Object}：当前动画的属性，比如当前动画的元素、·duration·\r\n    progress {Number}：当前动画的进度，范围·0~1·\r\n    remainingMs {Number}：当前动画剩余的时间，单位 ms\r\ncomplete {Function}：在动画完成时要执行的函数\r\ndone {Function(animation, jumpedToEnd)}：动画成功时执行的函数\r\nfail {Function(animation, jumpedToEnd)}：动画失败时执行的函数\r\nalways {Function(animation, jumpedToEnd)}：在动画完成时执行的函数\r\n!!\r\n\r\n### 淡入淡出\r\n!!\r\n.fadeOut()：以改变透明度的形式渐渐隐藏元素，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n.fadeIn()：以改变透明度的形式渐渐显示元素，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n.fadeToggle()：如果元素显示就淡出，隐藏就淡入，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n.fadeTo(duration, opacity [, easing] [, complete])：仅改变元素的透明度\r\n    duration {Number/String}：动画持续时间，单位 ms，可选·normal·(400)、·fast·(200)、·slow·(600)\r\n    opacity {Number}：目标透明度，范围 ·0~1·\r\n    easing {String} [swing]：运动曲线，可选 ·swing·（类似 ·ease·）或 ·linear·\r\n    complete {Function}：在动画完成时要执行的函数\r\n!!\r\n\r\n### 滑动\r\n\r\n!!\r\n.slideUp()：以改变高度的形式渐渐隐藏元素，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n.slideDown()：以改变高度的形式渐渐显示元素，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n.slideToggle()：如果元素显示就滑动隐藏，隐藏就滑动显示，不传参数默认动画时长 400ms，参数用法同·.hide()·\r\n!!\r\n\r\n### .animate()\r\n\r\n根据设置的 css 属性进行动画，2 种使用方式：\r\n·.animate(properties [, duration] [, easing] [, complete])·\r\n·.animate(properties, options)·\r\n参数·properties {Object}·是要设置的 css 属性和值的键值对，其他参数用法同·.hide()·\r\n可以提供一个以·+=·或·-=·开始的字符串值，那么目标值就是以这个属性的当前值加上或者减去给定的数字来计算的\r\n\r\n··js\r\n$('.demo').animate({\r\n    width: 200,\r\n    height: '+=50',\r\n    lateX: 400 // 自定义的值将从 0 开始变化，在 step 方法中使用\r\n}, {\r\n    duration: 1000,\r\n    specialEasing: {\r\n        width: 'linear',\r\n        height: 'swing'\r\n    },\r\n    step: function (now, tween) {\r\n        if (tween.prop == 'lateX') {\r\n            $(this).css('transform', 'translateX(' + now + 'px)')\r\n        }\r\n    },\r\n    progress: function (an, pro, ms) {\r\n        if (pro > 0.5) {\r\n            console.log('动画进行了一半')\r\n        }\r\n    }\r\n})\r\n··\r\n\r\n### .stop()\r\n\r\n停止当前动画：·.stop([queue] [, clearQueue] [, jumpToEnd])·\r\n\r\n!!\r\nqueue {String} [false]：指定要停止动画队列的名称\r\nclearQueue {Boolean} [false]：是否取消所有列队动画\r\njumpToEnd {Boolean} [false]：是否当前动画立即完成\r\n!!\r\n\r\n··js\r\n$('.demo').animate({ width: 600 }, 3000).animate({ width: 100 }, 2000)\r\n\r\n// 在 $('.demo') 进行第一个宽度变为 600 的动画中时：\r\n$('.demo').stop() // 停止当前动画，开始执行下一个动画宽变为 100\r\n$('.demo').stop(true) // 停止所有动画，因为把其余等待的动画队列清掉了\r\n$('.demo').stop(false, true) // 立即完成当前动画，即宽立即变为 600，开始执行下一个动画宽变为 100\r\n$('.demo').stop(true, true) // 立即完成当前动画并停止其他动画，因为把其余等待的动画队列清掉了\r\n··\r\n\r\n停止动画将不触发动画完成时的回调·complete·和·done·，将触发·fail·回调\r\n\r\n### .queue()\r\n\r\n!!\r\n.queue([queueName])：获取动画队列，返回一个数组，可传入一个参数指定要获取的名称\r\n.queue([queueName], newQueue)：可传入一个函数数组·newQueue·替换当前列队\r\n    传入空数组可清除动画队列，即当前动画执行完就停止动画\r\n.queue([queueName], callback(next))：可传入一个函数队列执行完之后要执行的函数\r\n!!\r\n\r\n### 其他\r\n\r\n!!\r\n.finish([queue])：立即完成所有动画\r\n    queue {String} [fx]：指定要完成动画队列的名称\r\n.delay(duration [, queue])：延迟动画\r\n    duration {Number/String}：动画要延迟的时间，单位 ms，可选·fast·(200)、·slow·(600)\r\n    queue {String} [fx]：指定延迟的动画队列的名称\r\n.dequeue([queueName])：执行队列\r\n    queueName {String} [fx]：指定要执行的动画队列的名称\r\n.clearQueue([queueName])：删除所有未执行的动画队列，等同于·.queue([])·\r\n    queueName {String} [fx]：指定要删除的动画队列的名称\r\n$.queue()：·.queue()·的另一种写法，元素作为第一个参数\r\n$.dequeue()：·.dequeue()·的另一种写法，元素作为第一个参数\r\njQuery.fx.off {Boolean} [false]：全局禁用所有动画，即立即完成动画\r\njQuery.fx.interval {Number} [13]：（在 v3.0 中已标记为弃用）全局设置动画的频率，单位 ms\r\n!!\r\n\r\n## Ajax\r\n\r\n### $.ajax()\r\n\r\n执行 http 请求：·$.ajax(url [, options])·或·$.ajax([options])·，·options {Object}·请求参数配置如下：\r\n\r\n!!\r\nurl {String} [当前页面地址]：请求地址\r\nasync {Boolean} [true]：是否异步\r\nmethod {String} [GET]：请求方法（1.9.0 之前的版本需使用 type）\r\ndata {Object/Array/String}：请求参数\r\nprocessData {Boolean} [true]：是否将·data·转换成查询字符串\r\ndataType {String} [通过 MIME 类型的响应信息判断]：指定返回的数据类型，可选：\r\n    text：纯文本字符串\r\n    xml： XML 文档\r\n    html：HTML 文本\r\n    script：执行该脚本并将该脚本以文本形式返回\r\n    json：JSON 格式，如果是不规范的 JSON 格式将报错\r\n    jsonp：跨域请求 JSON 数据，会在请求的 url 最后拼接·&callback=jQuery<随机数>_<timestamp>·\r\n    多个用空格分割的值：例如将 jsonp 以 text 接受并以 xml 解析使用·jsonp text xml·或简写·jsonp xml·\r\n\r\njsonp {String/Boolean}：在 jsonp 请求中指定·callback·为新名称，设为·false·将不添加该·callback·\r\njsonpCallback {String/Function}：在 jsonp 请求中指定·jQuery<随机数>_<timestamp>·为新名称\r\ncrossDomain {Boolean} [同域为 false, 跨域为 true]：指定是否跨域\r\ncontentType {Boolean/String} [application/x-www-form-urlencoded; charset=UTF-8]：指定传递的数据类型\r\ncontext：指定回调函数的上下文（下面有例子）\r\nglobal {Boolean} [true]：是否触发全局 Ajax 事件处理程序\r\nheaders {Object}：设置额外的请求头，例如 token\r\nscriptCharset {String}：在请求·script·脚本时设置其·charset·属性\r\ntimeout {Number}：设置请求超时时间，单位毫秒\r\n\r\nconverters {Object}：将返回的原始数据转换为 js 对象，每个转换器的值是一个函数，默认为：\r\n    ·{\"* text\": String, \"text html\": true, \"text json\": $.parseJSON, \"text xml\": $.parseXML}·\r\naccepts {Object} [取决于 dataType]：·dataType·的 MIME 类型，可自定义（下面有例子）\r\ncache {Boolean} [true(dataType 为 script/jsonp 时为 false)]：是否缓存此页面\r\ncontents {Object}：根据给定的内容类型，解析请求的返回结果\r\nifModified {Boolean} [false]：是否忽略 Last-Modified 头信息判断，只有上次请求响应改变时，才允许请求成功\r\nisLocal {Boolean} [取决于当前的位置协议]：是否允许当前环境被认定为本地\r\nmimeType {String}：指定一个 MIME 类型来覆盖 XHR 的 MIME 类型\r\nusername {String}：用于响应 http 访问认证请求的用户名\r\npassword {String}：用于响应 http 访问认证请求的密码\r\ntraditional {Boolean} [false]：是否以传统的方式来序列化数据（参考下方 url 序列化中的·$.param()·）\r\nxhr {Function}：默认为·XMLHttpRequest·对象，老版本 IE 为·ActiveXObject·\r\nxhrFields {Object}：设定原生的 XHR 对象，也可在跨域请求时用来设置·withCredentials·为·true·\r\n\r\nbeforeSend {Function(jqXHR, settings)}：请求前的回调函数，可修改请求的 jqXHR，返回·false·将取消这个请求\r\ndataFilter {Function(data, type)}：处理响应数据的函数，data 是返回的数据，type 是·dataType·参数\r\nstatusCode {Object}：响应状态码和对应执行的函数（下面有例子）\r\nsuccess {Function(data, textStatus, jqXHR)}：请求成功的回调函数，也可传入函数数组将被依次调用\r\nerror {Function(jqXHR, textStatus, errorThrown)}：请求失败的回调函数，也可传入函数数组将被依次调用\r\ncomplete {Function(jqXHR, textStatus)}：请求完成的回调函数，也可传入函数数组将被依次调用\r\n!!\r\n\r\n··js\r\n// accepts\r\n$.ajax({\r\n    accepts: {\r\n        mycustomtype: 'application/x-some-custom-type'\r\n    },\r\n    // 补充返回的数据的转换方法\r\n    converters: {\r\n        'text mycustomtype': function(result) {\r\n            // parse code\r\n            return newresult\r\n        }\r\n    },\r\n    dataType: 'mycustomtype'\r\n})\r\n\r\n// context\r\n$.ajax({\r\n    url: 'test.html',\r\n    context: document.body,\r\n    success: function () {\r\n        console.log(this) // body 元素\r\n    }\r\n})\r\n\r\n// statusCode\r\n$.ajax({\r\n    statusCode: {\r\n        404: function() {\r\n            alert('page not found')\r\n        }\r\n    }\r\n})\r\n··\r\n\r\n### 全局 Ajax\r\n\r\n!!\r\n$.ajaxSetup(options{Object})：配置·$.ajax()·的默认值，参数同·$.ajax()·\r\n$(document).ajaxStart(fn)：请求开始时执行的函数，和·ajaxSend·的区别在于当前进行的所有请求只触发一次\r\n$(document).ajaxSend(fn (event, jqXHR, ajaxOptions))：在每次请求发送之前执行的函数\r\n$(document).ajaxSuccess(fn (event, XMLHttpRequest, ajaxOptions))：在每次请求成功时执行的函数\r\n$(document).ajaxError(fn (event, jqXHR, ajaxSettings, thrownError))：在每次请求失败时执行的函数\r\n$(document).ajaxComplete(fn (event, XMLHttpRequest, ajaxOptions))：在每次请求完成时执行的函数\r\n$(document).ajaxStop(fn)：请求完成时执行的函数，和·ajaxComplete·的区别在于当前进行的所有请求只触发一次\r\n!!\r\n\r\n### 快捷方法\r\n\r\n!!\r\n$.get(url [, data] [, success] [, dataType])：get 请求，也可使用和·$.ajax()·一样的对象参数\r\n$.getJSON(url [, data] [, success)：get 请求获取 json 数据，即·dataType·默认为·json·\r\n$.getScript(url [, success])：get 请求获取 script 数据，即·dataType·默认为·script·\r\n$.post(url [, data] [, success] [, dataType])：post 请求，也可使用和·$.ajax()·一样的对象参数\r\n.load(url [, data] [, complete])：在指定元素中加载数据，即将返回的 HTML 数据插入至匹配的元素中\r\n    默认使用 get 请求，若·data·参数提供一个对象将使用 post 请求，不支持·jsonp·\r\n    在·url·参数中加入以空格隔开选择器可对返回的结果进行筛选，如·$('#result').load('/test.html #demo')·\r\n!!\r\n\r\n### url 序列化\r\n\r\n!!\r\n.serialize()：将表单内的元素转成查询字符串，形如·a=1&b=2·，表单元素应包含·name·和·value·属性\r\n    例如·$('form').serialize()·或·$('input, textarea, select').serialize()·\r\n.serializeArray()：将表单内的元素转成对象数组，形如·[{ name: a, value: 1 }, { name: b, value: 2 }]·\r\n$.param(obj [, traditional])：将对象、对象数组、表单元素转成的查询字符串\r\n    traditional {Boolean} [false]：是否不处理嵌套的对象，即直接转成字符串如·[object Object]·\r\n    注意此方法能力有限，对嵌套的对象或数组可能达不到预期\r\n!!\r\n\r\n#### $.param\r\n\r\n··js\r\nconst obj = {\r\n    a: {\r\n        one: 1,\r\n        two: 2,\r\n        three: 3\r\n    },\r\n    b: [1, 2, 3],\r\n    c: 'ss'\r\n}\r\n\r\nconsole.log($.param(obj))\r\n// a%5Bone%5D=1&a%5Btwo%5D=2&a%5Bthree%5D=3&b%5B%5D=1&b%5B%5D=2&b%5B%5D=3&c=ss\r\n// 即 a[one]=1&a[two]=2&a[three]=3&b[]=1&b[]=2&b[]=3&c=ss\r\n\r\nconsole.log($.param(obj, true))\r\n// a=%5Bobject%20Object%5D&b=1&b=2&b=3&c=ss\r\n// 即 a=[object Object]&b=1&b=2&b=3&c=ss\r\n··\r\n\r\n## 全局对象\r\n\r\n### $()\r\n\r\n!!\r\n$(selector [, content])：选择元素，第二个参数可指定范围，例如·$('span', this)·\r\n$(selector).length：获取匹配元素的数量\r\n$(element [, ownerDocument])：创建 DOM 元素，可在指定 document 内创建，例如·$('<div>123</div>')·\r\n$(element [, attributes])：创建 DOM 元素，可添加属性，例如·$('<div></div>', { class: 'demo' })·\r\n$(callback)：当 DOM 完成加载时执行函数，例如·$(function () {})·\r\n!!\r\n\r\n### $.extend()\r\n\r\n!!\r\n$.extend([deep], target [, ...obj])：将多个对象合并到第一个对象\r\n    deep {Boolean} [false]：是否深拷贝\r\n    target {Object}：目标对象\r\n    ...obj：被合并的对象，如果合并对象中有相同的属性则后面覆盖前面\r\n$.extend(object)：将自定义对象合并到 jQuery 对象中\r\n$.fn.extend()：·extend()·的另一种写法，即·$.extend === $.fn.extend·\r\n!!\r\n\r\n#### $.extend(object)\r\n\r\n··js\r\n$.extend({\r\n    check: function () {\r\n        return this.each(function () { this.checked = true })\r\n    },\r\n    uncheck: function () {\r\n        return this.each(function () { this.checked = false })\r\n    }\r\n})\r\n\r\n$('input[type=checkbox]').check()\r\n··\r\n\r\n#### jQuery extend 源码\r\n\r\n··js\r\njQuery.extend = jQuery.fn.extend = function() {\r\n    var options, name, src, copy, copyIsArray, clone,\r\n        target = arguments[ 0 ] || {},\r\n        i = 1,\r\n        length = arguments.length,\r\n        deep = false;\r\n\r\n    // 判断是否需要深拷贝\r\n    if ( typeof target === \"boolean\" ) {\r\n        deep = target;\r\n\r\n        // 目标对象改为第二个参数\r\n        target = arguments[ i ] || {};\r\n        i++;\r\n    }\r\n\r\n    // 当目标不是个对象或函数时则视为一个空对象\r\n    if ( typeof target !== \"object\" && !jQuery.isFunction( target ) ) {\r\n        target = {};\r\n    }\r\n\r\n    // 如果只传递一个参数将目标对象当作 jQuery 本身，即表示这是在 jQuery 上扩展新属性\r\n    if ( i === length ) {\r\n        target = this;\r\n        i--;\r\n    }\r\n\r\n    // 循环被合并的对象\r\n    for ( ; i < length; i++ ) {\r\n\r\n        // options 代表每项，null/undefined 不处理\r\n        if ( ( options = arguments[ i ] ) != null ) {\r\n\r\n            // name 代表每项的每个属性\r\n            for ( name in options ) {\r\n                src = target[ name ]; // 目标对象的同属性的属性值\r\n                copy = options[ name ]; // 被合并对象的当前属性值\r\n\r\n                // 防止无限循环，当目标对象和被合并对象的属性值相等 ???\r\n                if ( target === copy ) {\r\n                    continue;\r\n                }\r\n\r\n                // 如果是深拷贝，并且是个对象或数组则进行递归拷贝，copyIsArray 代表当前是个数组\r\n                if ( deep && copy && ( jQuery.isPlainObject( copy ) || ( copyIsArray = Array.isArray( copy ) ) ) ) {\r\n\r\n                    if ( copyIsArray ) {\r\n                        copyIsArray = false;\r\n                        clone = src && Array.isArray( src ) ? src : [];\r\n                        // 当目标对象的当前属性值不是数组或对象时用空数组或空对象代替，因为被合并对象的当前属性值是对象或数组\r\n                    } else {\r\n                        clone = src && jQuery.isPlainObject( src ) ? src : {};\r\n                    }\r\n\r\n                    // 递归调用自身拷贝子对象或数组\r\n                    target[ name ] = jQuery.extend( deep, clone, copy );\r\n\r\n                // 如果是浅拷贝则直接赋值，值为 undefined 时不合并\r\n                } else if ( copy !== undefined ) {\r\n                    target[ name ] = copy;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // 返回改变后的目标对象\r\n    return target;\r\n};\r\n··\r\n\r\n### $.noConflict()\r\n\r\n用于避免变量冲突，删除·$·变量，传入·true·会将·jQuery·变量也删掉，用变量接受返回的值即重命名·jQuery·\r\n\r\n··js\r\n// 只在闭包内使用 $\r\n$.noConflict()\r\n(function ($) {\r\n    // code...\r\n})(jQuery)\r\n\r\n// 用 _ 代替 $ 和 jQuery\r\nconst _ = $.noConflict(true)\r\n··\r\n\r\n### 工具\r\n\r\n!!\r\n$.isArray(obj)：判断是否是数组\r\n$.isPlainObject(obj)：判断是否是对象\r\n$.isEmptyObject(obj)：判断是否是空对象\r\n$.isFunction(obj)：判断是否是函数\r\n$.isNumeric(obj)：判断是否是数字\r\n$.isWindow(obj)：判断是否是·window·对象\r\n$.isXMLDoc(node)：检查一个 DOM 节点是否在 XML 文档中\r\n$.type(obj)：获取参数的类型，如：\r\n    ·undefined null boolean number string function array date error symbol regexp object·\r\n\r\n$.uniqueSort(array)：去重并排序一个由原生元素组成的数组\r\n$.merge(arr1, arr2)：将第二个数组的内容合并到第一个数组\r\n$.inArray(value, array [, fromIndex])：在数组中查找指定值的索引，没有找到则返回·-1·，类似·.indexOf()·\r\n$.trim(str)：去掉字符串开头和结尾的空白字符\r\n$.parseHTML(data [, context] [, isScripts])：返回一个将字符串解析成原生元素的数组\r\n$.parseXML(data)：将符合格式的字符串转换成 XML 格式\r\n$.proxy(function, context)：接受一个函数，然后返回一个新函数，并且这个新函数始终保持了特定的上下文语境\r\n$.globalEval(code)：执行代码，和·eval·的区别是全局执行，即在·<head>·中生成·<script>·执行\r\n\r\n$.now()：返回当前时间，等同于·Date.now()·\r\n$.ready：一个延迟对象，当文档准备就绪时，它处于·resolves·状态，可在·$.when()·中使用\r\n$.readyException(error)：定义此方法后，使用·$()·方法抛出错误时，此方法会触发\r\n$.error(message)：抛出异常错误，接收一个字符串转为参数，如果不是字符串会默认转换成字符串\r\n$.noop()：一个空函数，源码就是·noop: function () {}·，在传递空函数的时候可以用一下\r\n.jquery：获取 jQuery 脚本的版本号，返回字符串，例如·'3.2.1'·，使用方式：·$.fn.jquery·或·$().jquery·\r\n!!\r\n\r\n### 延迟对象\r\n\r\n使用·$.Deferred()·创建延时对象，用来处理异步操作如·$.ajax()·、·setTimeout·\r\n\r\n!!\r\ndeferred.done(function (data, textStatus, jqXHR))：等同于 ajax 的 success\r\ndeferred.fail(function (jqXHR, textStatus, errorThrown))：等同于 ajax 的 error\r\ndeferred.always(function (data|jqXHR, textStatus, jqXHR|errorThrown))：等同于 ajax 的 complete\r\ndeferred.then(function (即 jqXHR.done), function(即 jqXHR.fail))：包含·.done()·和·.fail()·方法\r\ndeferred.catch(function (即 jqXHR.fail))：等同于·deferred.then(null, fn)·\r\n\r\ndeferred.progress(callbacks, callbacks)：当延迟对象生成正在执行中的进度通知时，调用添加处理程序\r\n    callbacks {Function/ArrayFunction}：当延迟对象生成正在执行中的进度通知时被调用\r\n    callbacks {Function/ArrayFunction}：附加的函数\r\ndeferred.notify(args)：调用延迟对象上进行中的回调\r\n    args {Object}：传递参数给进行中的回调\r\ndeferred.notifyWith(context [, args])：调用延迟对象上进行中的回调\r\n    context {Object}：Context（上下文） 作为 this 对象传递给进行中的回调\r\n    args {Array}：一个可选的参数数组传递给进行中的回调\r\ndeferred.resolve(args)：调用成功的回调函数，参数同·notify·\r\ndeferred.resolveWith(context [, args])：调用成功的回调函数，参数同·notifyWith·\r\ndeferred.reject(args)：调用失败的回调函数，参数同·notify·\r\ndeferred.rejectWith(context [, args])：调用失败的回调函数，参数同·notifyWith·\r\ndeferred.state()：返回一个字符串，表示延迟对象的当前状态，值为·pending、resolved、rejected·中的一种\r\ndeferred.promise()：返回延迟的 Promise 对象\r\n\r\n.promise([type] [, target])：为 DOM 绑定延迟对象，通常用于动画中\r\n    type {String} [fx]：需要待观察队列类型\r\n    target {Object} [fx]：将要绑定 promise 方法的对象\r\n\r\n$.when()：可让零到多个延迟对象执行延迟方法\r\n!!\r\n\r\n#### deferred.promise()\r\n\r\n··js\r\nconst obj = {\r\n    hello: function (name) {\r\n        alert('Hello' + name )\r\n    }\r\n}\r\nconst defer = $.Deferred() // 创建延时对象\r\n\r\ndefer.promise(obj) // 创建 promise\r\ndefer.resolve('John') // 调用成功\r\n\r\nobj.done(function(name) {\r\n    obj.hello(name) // 先 John\r\n}).hello('Karl') // 后 Karl\r\n··\r\n\r\n#### .promise()\r\n\r\n··js\r\n// 当前所有动画完成后触发 done\r\n$('div').each(function(i) {\r\n    $(this).fadeIn().fadeOut(1000 * (i + 1))\r\n}).promise().done(function () {\r\n    console.log('finfsh!')\r\n})\r\n··\r\n\r\n#### $.when()\r\n\r\n使用·$.when(deferreds)·可让零到多个延迟对象执行延迟方法\r\n当延迟对象都被解决（resolved）将触发成功的回调，任意一个被拒绝（rejected）将触发失败的回调\r\n\r\n··js\r\n// 都请求成功触发 successFn，任意一个失败触发 failFn\r\n$.when($.ajax('/page1'), $.ajax('/page2'))\r\n    .then(successFn, failFn)\r\n··\r\n\r\n### 回调对象\r\n\r\n管理回调函数列表\r\n\r\n!!\r\n$.Callbacks(flags)：创建回调对象\r\n    flags：回调对象的配置，以空格隔开的字符串，支持的参数有：\r\n        once：回调列表只执行第一次，即只执行第一个·fire()·\r\n        memory：将添加到这个列表的后面的最新的回调立即执行\r\n        unique：不添加重复的回调\r\n        stopOnFalse：当一个回调返回·false·时中断调用\r\ncallbacks.add(callbacks)：添加一个函数或数组函数到回调列表\r\ncallbacks.fire(arguments)：传入一个参数并调用所有回调函数\r\ncallbacks.fireWith([context] [, args])：传入一个上下文（·this·）和一个参数并调用所有回调函数\r\ncallbacks.fired()：返回一个 Boolean 值，判断回调是否至少被调用过一次\r\ncallbacks.has(callback)：返回一个 Boolean 值，传入一个参数回调，判断回调列表中是否有该回调\r\ncallbacks.disable()：禁止调用回调\r\ncallbacks.lock()：锁定当前状态，和·disable·的区别在于·memory·状态下会触发新添加的回调，·disable·不会\r\ncallbacks.locked()：返回一个 Boolean 值，判断回调列表是否已被锁定\r\ncallbacks.remove(callbacks)：在回调列表中删除一个函数或数组函数\r\ncallbacks.empty()：删除所有回调\r\n!!\r\n\r\n··js\r\nconst foo = str => console.log(str)\r\nconst bar = str => foo('bar: ' + str)\r\nconst callbacks = $.Callbacks() // 创建回调对象\r\n\r\ncallbacks.add(foo) // 添加 foo\r\ncallbacks.fire('foo') // foo\r\n\r\ncallbacks.add(bar) // 添加 bar\r\ncallbacks.fire('foo')\r\n// foo\r\n// bar: foo\r\n\r\ncallbacks.remove(bar)\r\ncallbacks.fire('foo') // foo\r\n··\r\n\r\n@@\r\n[jQuery 官网](https://jquery.com/)\r\n[jQuery 中文](https://www.jquery123.com/)\r\n[HTML 中文网 jQuery 文档](https://www.css88.com/jqapi-1.9/)\r\n[插件 - jQuery插件库](http://www.jq22.com/)\r\n[插件 - jQuery之家](http://www.htmleaf.com/)\r\n@@\r\n\r\n&2019/3/28\r\n`\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./jquery.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./jquery.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./jquery.vue?vue&type=template&id=1c0ddbf5&\"\nimport script from \"./jquery.vue?vue&type=script&lang=js&\"\nexport * from \"./jquery.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}