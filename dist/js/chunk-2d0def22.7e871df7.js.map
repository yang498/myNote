{"version":3,"sources":["webpack:///./src/pages/article/js/connect.vue?4001","webpack:///src/pages/article/js/connect.vue","webpack:///./src/pages/article/js/connect.vue?f928","webpack:///./src/pages/article/js/connect.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"yHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,yoFCR+W,I,YCO3WC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d0def22.7e871df7.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# 网络请求\r\n\r\n## WebSocket\r\n\r\n### 介绍\r\n\r\nHTTP 协议有一个缺陷：通信只能由客户端发起，做不到服务器主动向客户端推送信息\r\n例如聊天室，如果服务器有连续的状态变化，客户端要获知就非常麻烦，只能使用轮询或长连接\r\nWebSocket 协议在 2008 年诞生，2011 年成为国际标准。所有浏览器都已经支持了\r\n最大的特点就是：服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，它们之间存着一条持续打开的数据通道\r\n其他特点：\r\n\r\n!!\r\n建立在 TCP 协议之上，服务器端的实现比较容易\r\n与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443\r\n数据格式比较轻量，性能开销小，通信高效\r\n可以发送文本，也可以发送二进制数据\r\n没有同源限制，客户端可以与任意服务器通信，完全可以取代 Ajax\r\n协议标识符是·ws·（如果加密，则为·wss·，对应 HTTPS 协议），服务器网址就是 URL\r\n!!\r\n\r\n### 握手请求\r\n\r\n浏览器发出的 WebSocket 握手请求形如：\r\n\r\n··js\r\nGET / HTTP/1.1\r\nConnection: Upgrade // 浏览器通知服务器升级到 WebSocket 协议\r\nUpgrade: websocket // 将通信协议从 HTTP/1.1 转向该字段指定的协议\r\nHost: example.com\r\nOrigin: null // 发出的域名，供服务器验证是否许可的范围内（服务器也可以不验证）\r\nSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ== // 握手协议的密钥，是 Base64 编码的16字节随机字符串\r\nSec-WebSocket-Version: 13\r\n··\r\n\r\n服务器的 WebSocket 回应形如：\r\n\r\n··js\r\nHTTP/1.1 101 Switching Protocols\r\nConnection: Upgrade\r\nUpgrade: websocket\r\nSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=\r\nSec-WebSocket-Origin: null\r\nSec-WebSocket-Location: ws://example.com/\r\n··\r\n\r\n### API\r\n\r\n浏览器对 WebSocket 协议的处理就是三件事：建立和断开连接、发送和接收数据、处理错误\r\n\r\n!!\r\nnew WebSocket(url, [protocols])：新建 WebSocket 实例，让客户端与服务器进行连接\r\n    url{s}：要连接的 url，使用·ws·或·wss·协议\r\n    protocols {String/Array}：指定子协议，让单个服务器可以实现多个 WebSocket 子协议\r\n\r\nws.readyState：实例对象的当前状态，可能的值：\r\n    WebSocket.CONNECTING [0]：表示正在连接\r\n    WebSocket.OPEN [1]：表示连接成功，可以通信了\r\n    WebSocket.CLOSING [2]：表示连接正在关闭\r\n    WebSocket.CLOSED [3]：表示连接已经关闭，或者打开连接失败\r\nws.binaryType：指定接收的二进制数据类型，可指定的类型：\r\n    blob：收到的是 blob 数据\r\n    arraybuffer：收到的是 ArrayBuffer 数据\r\nws.bufferedAmount：还未发送出去的二进制数据，可以用来判断发送是否结束\r\nws.extensions：服务器已选择的扩展值，目前链接可以协定的扩展值只有空字符串或者一个扩展列表\r\nws.protocol：服务器端选中的子协议名称\r\nws.url：实例对象的 url\r\n\r\nws.send(data)：向服务器发送数据，·data·接受的类型：\r\n    <String>：文本字符串\r\n    <Blob>：二进制大对象\r\n    <ArrayBuffer>：二进制数据\r\n    <ArrayBufferView>：二进制帧\r\nws.close([code, reason])：关闭当前连接\r\n    code [1005]：指定关闭的状态码，详见[状态码列表](https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes)\r\n    reason：说明连接关闭的原因，长度不能超过 123 个字节\r\n\r\nws.onopen：连接成功时触发\r\nws.onclose：连接关闭时触发\r\nws.onmessage：收到服务器数据时触发\r\nws.onerror：报错时的回调函数\r\n!!\r\n\r\n示例：\r\n\r\n··js\r\nlet ws = new WebSocket('wss://www.websocket.com/ws')\r\n\r\nws.addEventListener('open', res => {\r\n    console.log('连接成功')\r\n    console.log(res)\r\n})\r\nws.addEventListener('message', res => {\r\n    console.log('连接成功')\r\n    console.log(res)\r\n})\r\nws.addEventListener('close', res => {\r\n    console.log('已关闭连接')\r\n    console.log(res)\r\n})\r\nws.addEventListener('error', res => {\r\n    console.log('连接错误')\r\n    console.log(res)\r\n})\r\n$sendBtn.addEventListener('click', e => {\r\n    ws.send('hello')\r\n})\r\n$closeBtn.addEventListener('click', e => {\r\n    ws.close()\r\n})\r\n··\r\n\r\n@@\r\n[socket.io](https://socket.io)\r\n@@\r\n\r\n&2019/10/23\r\n`\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./connect.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./connect.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./connect.vue?vue&type=template&id=5d4c7735&\"\nimport script from \"./connect.vue?vue&type=script&lang=js&\"\nexport * from \"./connect.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}