(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0b2198"],{2356:function(n,e,o){"use strict";o.r(e);var t=function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{domProps:{innerHTML:n._s(n.format(n.text))}})},r=[],b={data:function(){return{text:"\n# object\n\n## 概述\n\n### 定义\n\n一组无序键值对（key-value）的集合，以大括号包裹，键值对之间以逗号·,·分隔，键与值之间以冒号·:·分隔\n\n··js\nvar obj = {\n    foo: 'Hello',\n    bar: 'World'\n}\n\n// 修改增加\nobj.foo = 123\nobj.foo2 = 234\n··\n\n### 键名命名规范\n\n若省略引号则不能包含空格或运算符\n以数字开头和非数字字符的组合须加上引号\n\n··js\n// 报错\nvar obj = {\n    1p: 'Hello World'\n}\n\n// 不报错\nvar obj = {\n    20: 'Hello World',\n    p1: 'Hello World',\n    '1p': 'Hello World',\n    'h w': 'Hello World',\n    'p+q': 'Hello World'\n}\n··\n\n### 对象引用\n\n如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址\n修改其中一个变量，会影响到其他所有变量\n\n··js\nvar o1 = {}\nvar o2 = o1\n\no1.a = 1\no2.a // 1\n\no2.b = 2\no1.b // 2\n··\n\n但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝\n\n··js\nvar x = 1\nvar y = x\n\nx = 2\ny // 1\n··\n\n### 表达式还是语句？\n\n对象采用大括号表示，所以如果行首是一个大括号，它是表达式表示一个对象还是语句表示一段代码？\n为了避免这种歧义，JavaScript 引擎的做法是一律解释为代码块\n\n··js\n{ console.log(123) } // 123\n··\n\n如果要解释为对象，最好在大括号前加上圆括号。因为圆括号里面只能是表达式\n\n··js\n({ foo: 123 }) // 正确\n({ console.log(123) }) // 报错\n··\n\n这种差异在·eval·语句（作用是对字符串求值）中反映得最明显\n\n··js\neval('{foo: 123}') // 123\neval('({foo: 123})') // {foo: 123}\n··\n\n### 读取属性\n\n使用点运算符·.·或方括号运算符·[]·\n注意，使用方括号运算符·[]·时，键名必须放在引号里面（数字除外），否则是个变量\n方括号运算符内部还可以使用表达式运算\n\n··js\nvar obj = {\n    p: 'Hello World'\n}\n\nobj.p // \"Hello World\"\nobj['p'] // \"Hello World\"\n··\n\n### delete\n\n·delete·命令用于删除对象的属性，删除成功后返回·true·\n\n··js\nvar obj = { p: 1 }\ndelete obj.p\nobj // {}\n··\n\n注意，删除一个不存在或继承的属性，·delete·不报错且返回·true·，只有当该属性存在且不得删除时使用·delete·会返回·false·\n\n··js\nvar obj = Object.defineProperty({}, 'p', {\n    value: 123,\n    configurable: false\n})\nobj.p // 123\ndelete obj.p // false\n··\n\n### in\n\n·in·运算符用于检查对象是否包含某个属性（键名，不是键值），左边是属性名，右边是一个对象\n注意，继承的属性也会返回·true·，可使用对象的·hasOwnProperty·方法判断是否为对象自身的属性\n\n··js\nvar obj = { p: 1 }\n'p' in obj // true\n'toString' in obj // true\nobj.hasOwnProperty('toString') // false\n··\n\n### for...in\n\n遍历一个对象的全部属性\n\n··js\nvar obj = { a: 1, b: 2, c: 3 }\n\nfor (var i in obj) console.log(i)\n// a\n// b\n// c\n··\n\n### with\n\n操作同一个对象的多个属性时，提供一些书写的方便\n\n··js\nvar obj = {\n    p1: 1,\n    p2: 2\n}\n\nwith (obj) {\n    p1 = 4\n    p2 = 5\n}\n// 等同于\nobj.p1 = 4\nobj.p2 = 5\n··\n\n注意，·with·内部操作的必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量\n\n··js\nvar obj = {}\nwith (obj) {\n    p1 = 4\n}\n\nobj.p1 // undefined\np1 // 4\n··\n\n因此，不建议使用·with·语句，用一个临时变量代替\n\n## 属性描述对象\n\n### 介绍\n\nJavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等\n这个内部数据结构称为“属性描述对象”（attributes object），可通过一些静态方法来操作\n\n··js\n{\n    value: 123,\n    writable: true,\n    enumerable: true,\n    configurable: true,\n    get: undefined,\n    set: undefined\n}\n··\n\n!!\nvalue [undefined]：属性值\nwritable {Boolean} [true]：·value·是否可改变，若设为·false·可通过·Object.defineProperty/ies()·修改\nenumerable {Boolean} [true]：·value·是否可遍历\nconfigurable {Boolean} [true]：·value·是否可修改属性描述对象，和是否可删除此属性\n    若·configurable·设为·false·，则修改·writable·将·true·改为·false·是允许的\n    至于·value·，只要·writable·和·configurable·有一个为·true·，就允许改动\nget {Function}：取值函数（getter）\nset {Function}：存值函数（setter），接受赋予的值作为参数\n    注意，若定义了·get·或·set·，就不能将·writable·属性设为·true·，也不能设置·value·\n        因为此时获取该属性返回的不是·value·，而是·get·返回的值，同理，赋值时就会调用·set·\n!!\n\n### 写法\n\n第一种是通过·Object.defineProperty/ies()·定义：\n\n··js\nvar obj = Object.defineProperty({}, 'p', {\n    get: function () {\n        return 'getter'\n    },\n    set: function (value) {\n        console.log('setter: ' + value)\n    }\n})\n\nobj.p // \"getter\"\nobj.p = 123 // \"setter: 123\"\n··\n\n第二种是直接在对象上定义，方法名即属性名：\n\n··js\nvar obj = {\n    get p() {\n        return 'getter'\n    },\n    set p(value) {\n        console.log('setter: ' + value)\n    }\n}\n··\n\n### 用法\n\n存取器往往用于，属性的值依赖对象内部数据的场合：\n\n··js\n// next 属性的存值函数和取值函数，都依赖于内部属性 $n\nvar obj ={\n    $n : 5,\n    get next() { return this.$n++ },\n    set next(n) {\n        if (n >= this.$n) this.$n = n\n        else throw new Error('新的值必须大于当前值')\n    }\n}\n\nobj.next // 5\n\nobj.next = 10\nobj.next // 10\n\nobj.next = 5\n// Uncaught Error: 新的值必须大于当前值\n··\n\n### 对象的拷贝\n\n有时，我们需要将一个对象的所有属性，拷贝到另一个对象：\n\n··js\nvar extend = function (to, from) {\n    for (var property in from) to[property] = from[property]\n    return to\n}\n\nextend({}, { a: 1 }) // {a: 1}\n··\n\n但如果遇到存取器定义的属性，会只拷贝值：\n\n··js\nextend({}, {\n    get a() { return 1 }\n})\n// {a: 1}\n··\n\n可以通过·Object.defineProperty()·来拷贝属性描述对象\n\n··js\nvar extend = function (to, from) {\n    for (var property in from) {\n        if (from.hasOwnProperty(property)) {\n            Object.defineProperty(\n                to,\n                property,\n                Object.getOwnPropertyDescriptor(from, property)\n            )\n        }\n    }\n    return to\n}\n\nextend({}, { get a() { return 1 } })\n// { get a(){ return 1 } })\n··\n\n## Object\n\nJavaScript 的所有其他对象都继承自·Object·对象，即那些对象都是·Object·的实例\n\n### Object()\n\n·Object·本身是一个函数，可以当作工具方法使用，将任意值转为对象\n如果参数为空（或者为·undefined·和·null·），·Object()·返回一个空对象\n\n··js\nvar obj = Object()\nvar obj = Object(undefined)\nvar obj = Object(null)\n··\n\n### instanceof\n\n验证一个对象是否为指定的构造函数的实例\n当对·Object·函数传入原始类型的值时返回原始类型值对应的包装对象\n\n··js\nvar obj = Object(1)\nobj instanceof Object // true\nobj instanceof Number // true\n··\n\n如果·Object·方法的参数是一个对象则返回该对象，即不用转换\n\n··js\nvar value = {}\nvar obj = Object(value) // 返回原对象\nobj === value // true\n··\n\n判断变量是否为对象（包括数组、函数）：\n\n··js\nfunction isObject(value) {\n    return value === Object(value)\n}\n··\n\n### new Object()\n构造函数可以用来生成新对象，以下写法相等\n\n··js\nvar obj = new Object()\nvar obj = Object()\nvar obj = {}\n··\n\n其中·Object(value)·表示将·value·转成一个对象，·new Object(value)·则表示新生成一个对象\n\n## 静态方法\n\n!!\nObject.keys(obj)：返回一个由参数对象的键名组成的数组，只返回可遍历的属性\nObject.getOwnPropertyNames(obj)：用法和·Object.keys()·一样，且可返回不可遍历的属性，例如数组的·length·\n\nObject.getOwnPropertyDescriptor(obj, key)：获取属性描述对象，只能用于自身的属性，不能用于继承的属性\nObject.getPrototypeOf(obj)：获取对象的·Prototype·对象\nObject.create(obj)：指定原型对象和属性，返回一个新的对象，即复制对象\n\nObject.defineProperty(obj, key, attrObj)：定义或修改属性描述对象，返回修改后的对象\nObject.defineProperties(obj, {keys: attrObjs})：：定义或修改多个属性描述对象，返回修改后的对象\n    若·defineProperty/ies()·未定义·writable configurable enumerable·则默认都为·false·\n\nObject.preventExtensions(obj)：禁止对象添加新的属性\nObject.seal(obj)：禁止对象添加新的属性，也不能删除已有的属性，即把·configurable·属性设为·false·\nObject.freeze(obj)：禁止对象添加新属性、删除旧属性、改变属性值，若子属性还是对象则无法冻结，可循环深冻结\n\nObject.isExtensible(obj)：判断对象是否可扩展\nObject.isSealed(obj)：判断对象是否可配置\nObject.isFrozen(obj)：判断对象是否被冻结\n!!\n\n## 实例方法\n\n以下方法前面省略·Object.prototype.·\n\n!!\nvalueOf()：返回对象的原始值，默认返回对象本身，主要用于自动类型转换时调用\ntoString()：返回对象的字符串形式，即·\"[object Object]\"·，不同类型返回对应的值\ntoLocaleString()：和·toString()·返回的结果相同，作用是方便自定义，例如·Date·对象就自定义过\n\nisPrototypeOf()：判断当前对象是否为另一个对象的原型\nhasOwnProperty(key)：判断对象是否有某属性，只能判断自身的属性，继承的属性只会返回·false·\npropertyIsEnumerable()：判断某个属性是否可遍历，只能判断自身的属性，继承的属性只会返回·false·\n!!\n\n## es6\n\n### 属性\n\n!!\n__proto__：用来读取或设置当前对象的·prototype·对象\n    前后的双下划线说明它本质上是一个内部属性，并从兼容性考虑，所以尽量不直接操作这个属性\n    可使用·Object.setPrototypeOf()·、·Object.getPrototypeOf()·、·Object.create()·组合代替\n!!\n\n### 静态方法\n\n!!\nObject.is(a, b)：比较两个值是否相等，和·===·类似，还包括可以比较·NaN·、·-0·不等于·+0·或·0·\nObject.assign(target, ...source)：将源对象复制到目标对象，若有同名属性则后面覆盖前面\nObject.getOwnPropertyDescriptors(obj)：返回对象上所有属性的描述对象\nObject.setPrototypeOf(obj, proto)：设置一个对象的·prototype·对象，返回参数对象本身\nObject.values()：返回对象的键值组成的数组，只返回可遍历的属性\nObject.entries()：返回对象的键值对数组组成的数组，只返回可遍历的属性\nObject.fromEntries()：将一个键值对数组转为对象，即·Object.entries()·的逆操作\n!!\n\n### 属性简写\n\n若属性和变量名相同则可简写成一个：\n\n··js\nconst foo = 'abc'\nconst obj = { foo }\n// 等同于\nconst obj = { foo: foo }\n··\n\n方法也可以简写：\n\n··js\nconst o = {\n    method () {\n        return \"Hello!\"\n    }\n}\n// 等同于\nconst o = {\n    method: function () {\n        return \"Hello!\"\n    }\n}\n··\n\n### 属性表达式\n\n可使用方括号将属性名定义变量：\n\n··js\nlet propKey = 'foo'\n\nlet obj = {\n    [propKey]: true,\n    ['a' + 'bc']: 123\n}\n··\n\n还可用于方法名的简写：\n\n··js\nlet obj = {\n    ['h' + 'ello'] () {\n        return 'hi'\n    }\n}\n··\n\n但不能用于属性的简写，否则报错：\n\n··js\nconst baz = { [foo] } // 报错\n··\n\n注意，若属性名表达式返回的是对象则会转换成字符串\n\n### 方法的 name 属性\n\n函数的·name·属性返回函数名。对象方法也是函数，也有·name·属性：\n若是取值函数（getter）和存值函数（setter），则·name·属性不在该方法上，而在属性的描述对象的·get·和·set·属性上：\n\n··js\nconst obj = {\n    get foo() {},\n    set foo(x) {}\n}\nconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo')\ndescriptor.get.name // \"get foo\"\ndescriptor.set.name // \"set foo\"\n··\n\n·Function·构造函数创造的函数，·name·属性返回·anonymous·\n\n··js\n(new Function()).name // \"anonymous\"\n··\n\n·bind·方法创造的函数，·name·属性返回·bound·加上原函数的名字\n\n··js\nconst doSomething = function () {}\ndoSomething.bind().name // \"bound doSomething\"\n··\n\n如果对象的方法是·Symbol·值则返回这个·Symbol·值的描述\n\n··js\nconst key = Symbol('description')\nlet obj = {\n    [key] () {},\n}\nobj[key].name // \"[description]\"\n··\n\n### super\n\n·this·总是指向函数所在的当前对象，而·super·指向当前对象的原型对象，且只能用在对象的**简写**方法之中\n\n··js\nconst obj = {\n    name: '张三',\n    getName: function () {\n        console.log(this.name)\n    }\n}\nobj.getName() // 张三\n··\n\n··js\nconst obj = {\n    foo: 'world',\n    find () {\n        console.log(super.foo)\n    }\n}\nconst proto = {\n    foo: 'hello'\n}\n\nobj.find() // undefined\nobj.__proto__ = proto\nobj.find() // \"hello\"\n··\n\n以下写法错误：\n\n··js\n// 不能用于属性\nconst obj = {\n  foo: super.foo\n}\n\n// 不是属性方法的简写形式\nconst foo = {\n    foo: () => super.foo\n}\nconst bar = {\n    bar: function () {\n        return super.bar\n    }\n}\n··\n\n其实·super.foo·等同于·Object.getPrototypeOf(this).foo·\n或·super.foo()·等同于·Object.getPrototypeOf(this).foo.call(this)·\n\n### 扩展运算符\n\n扩展运算符·...·可取出对象的所有可遍历属性，并需要对象容器包裹\n\n#### 解构赋值\n\n将剩余的值拷贝到新对象上\n\n··js\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }\nx // 1\ny // 2\nz // { a: 3, b: 4 }\n··\n\n#### 拷贝对象\n\n空对象和除了字符串以外的类型将没有效果\n\n··js\nlet z = { a: 3, b: 4 }\nlet n = { ...z }\nn // { a: 3, b: 4 }\n\nlet foo = { ...['a', 'b', 'c'] }\nfoo // {0: \"a\", 1: \"b\", 2: \"c\"}\n\n{...'hello'} // {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"}\n··\n\n等同于使用·Object.assign()·：\n\n··js\nlet aClone = { ...a }\n// 等同于\nlet aClone = Object.assign({}, a)\n··\n\n可以用于合并两个对象，若有相同属性则后面覆盖前面：\n\n··js\nlet ab = { ...a, ...b }\nlet axy = { ...a, x: 1, y: 2 }\n··\n\n扩展运算符后面可以跟表达式：\n\n··js\nconst obj = {\n  ...(x > 1 ? {a: 1} : {}),\n  b: 2\n}\n··\n\n&2019/08/03\n            "}}},j=b,a=o("2877"),s=Object(a["a"])(j,t,r,!1,null,null,null);e["default"]=s.exports}}]);
//# sourceMappingURL=chunk-2d0b2198.14a9195a.js.map