(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d0d7d7d"],{7916:function(e,n,t){"use strict";t.r(n);var l=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{domProps:{innerHTML:e._s(e.format(e.text))}})},r=[],a={data:function(){return{text:'\n# 浏览器\n\n## URL\n\n·<a>·元素和·<area>·元素都部署了这个接口。即它们的 DOM 节点对象可以使用 URL 的实例属性和方法\n\n··js\nvar a = document.createElement(\'a\')\na.href = \'http://example.com/?foo=1\'\n\na.hostname // "example.com"\na.search // "?foo=1"\n··\n\n### new URL\n\n·new URL(url)·：接受一个·url·生成·URL·实例\n\n··js\nvar url = new URL(\'http://www.example.com/index.html\')\nurl.href // "http://www.example.com/index.html"\n··\n\n·new URL(relUrl, absUrl)·：如果 url 是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准\n\n··js\nvar url1 = new URL(\'index.html\', \'http://example.com\')\nurl1.href // "http://example.com/index.html"\n\nvar url2 = new URL(\'page2.html\', \'http://example.com/page1.html\')\nurl2.href // "http://example.com/page2.html"\n\nvar url3 = new URL(\'..\', \'http://example.com/a/b.html\')\nurl3.href // "http://example.com/"\n··\n\n### 实例方法\n\n（URL 实例的属性同 location 对象）\n\n!!\nURL.createObjectURL(file)：用来为上传/下载的文件、流媒体文件生成一个 URL 字符串，以·blob:·开头\n    这个 URL 对应内存的一个 Blob 对象，与·data://URL·（URL 包含实际数据）和·file://URL·（本地文件系统里面的文件）都不一样\nURL.revokeObjectURL(blobUrl)：释放·createObjectURL()·生成的实例以节省内存，参数即·createObjectURL()·返回的 url\n!!\n\n预览上传的图片\n\n··js\n// <input id="file" type="file" accept="image/*"/>\n// <img id="img"/>\n\nconst $file = document.querySelector(\'#file\')\nconst $img = document.querySelector(\'#img\')\n$file.onchange = function () {\n    $img.src = URL.createObjectURL(this.files[0]) // 形如 blob:http://localhost/c745ef73-ece9-46da-8f66-ebes574789b1\n}\n··\n\n## URLSearchParams\n\n·URLSearchParams·对象用于处理 url 的查询字符串（即 url 问号后面的部分）\n\n## Blob\n\nBlob (Binary Large Object)：二进制大对象，Blob 对象表示一个二进制文件的数据内容，通常用来读写文件\n\n·new Blob(array [, options])·：生成实例对象\n\n!!\narray {Array}：由字符串或二进制对象组成的数组\noptions {Object}：配置\n    type {String}：数据的 MIME 类型，[参考 MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Complete_list_of_MIME_types)\n!!\n\n返回的实例属性方法\n\n!!\nmyBlob.size {Number}：数据的大小\nmyBlob.type {String}：数据的类型\nmyBlob.slice([start, end, contentType])：拷贝原来的数据并返回一个·Blob·实例\n    start {Number} [0]：指定起始的字节位置\n    end {Number} [myBlob.size]：指定结束的字节位置，该位置本身将不包含在拷贝的数据之中\n    contentType {String}：数据类型\n!!\n\n保存 html 数据：\n\n··js\nconst htmlFragment = \'<a id="a"><b id="b">hey!</b></a>\'\nconst myBlob = new Blob([htmlFragment], {type: \'text/html\'})\n\nmyBlob.size // 32\nmyBlob.type // "text/html"\n··\n\n## File\n\n·File·对象代表一个文件，用来读写文件信息，继承自·Blob·对象\n\n### new File\n\n·new File(array, name [, options])·：主动生成·File·实例对象\n\n!!\narray {Array}：以二进制对象或字符串组成的数组，表示文件的内容\nname {String}：文件名或文件路径\noptions {Object}：设置实例的属性\n    type {String}：实例对象的 MIME 类型\n    lastModified {Number}[Date.now()]：上次修改的时间\n!!\n\n··js\nconst file = new File([\'foo\'], \'foo.txt\', {type: \'text/plain\'})\n··\n\n生成实例对象后的属性：\n\n!!\nFile.name：文件名或文件路径\nFile.size：文件大小（单位字节）\nFile.type：文件的 MIME 类型\nFile.lastModified：最后修改时间的时间戳格式\nFile.lastModifiedDate：最后修改时间的字符串格式\nFile.slice()：复制截取原来的数据，此方法继承于·Blob·对象\n!!\n\n··js\nconst myFile = new File([], \'file.bin\', {lastModified: new Date(2018, 1, 1)})\nmyFile.name // "file.bin"\nmyFile.size // 0\nmyFile.type // ""\nmyFile.lastModified // 1517414400000\nmyFile.lastModifiedDate // Thu Feb 01 2018 00:00:00 GMT+0800 (中国标准时间)\n··\n\n### FileList\n\n类似数组的对象，代表一组选中的文件，每个成员都是一个·File·实例对象，实例对象的属性同上·new File·的\n它主要出现在两个场合：\n\n!!\n选择文件：·<input type="file">·的·files·属性\n拖拽文件：目标区的·DataTransfer.files·属性\n!!\n\n··js\n// <input id="file" type="file"/>\n\nconst file = document.querySelector(\'#file\').files[0]\nfile instanceof File // true\n··\n\n有个·item()·方法可以选择哪个文件，但方括号可以直接选择，即·files[0]·等同于·files.item(0)·，所以用不上了\n\n### new FileReader\n\n读取·File·对象或·Blob·对象，返回的实例属性：\n\n!!\nFileReader.error {Error}：读取文件时产生的错误对象\nFileReader.readyState {Number}：读取文件时的当前状态，·0·尚未加载，·1·正在加载，·2·加载完成\nFileReader.result：读取完成后的文件内容\n\nFileReader.onabort：abort 事件（用户终止读取操作）的监听函数。\nFileReader.onerror：error 事件（读取错误）的监听函数。\nFileReader.onload：load 事件（读取操作完成）的监听函数，通常在这个函数里面使用·result·属性，拿到文件内容\nFileReader.onloadstart：loadstart 事件（读取操作开始）的监听函数\nFileReader.onloadend：loadend 事件（读取操作结束）的监听函数\nFileReader.onprogress：progress 事件（读取操作进行中）的监听函数\n\nFileReader.abort(file)：终止读取操作，·readyState·属性将变成·2·\nFileReader.readAsArrayBuffer(file)：以·ArrayBuffer·的格式读取文件\nFileReader.readAsBinaryString(file)：以·BinaryString·的格式读取文件\nFileReader.readAsDataURL(file)：以·DataURL·（Base64 编码）的格式读取文件，对于图片文件可直接用于·<img>·的·src·属性\n    注意，不能直接对 Base64 解码，必须把前缀·data:*/*;base64,·从字符串里删除后再进行\nFileReader.readAsText(file [, encode])：以·text·的格式读取文件\n    file：文件的 Blob 实例\n    encode [UTF-8]：文本编码\n!!\n\n预览上传的图片：\n\n··js\n// <input id="file" type="file" accept="image/*"/>\n// <img id="img"/>\n\nconst $file = document.querySelector(\'#file\')\nconst $img = document.querySelector(\'#img\')\n$file.onchange = function () {\n    const reader = new FileReader()\n    if (this.files[0]) reader.readAsDataURL(this.files[0]) // 加个判断防止选择文件时点击取消也会触发\n    reader.onload = () => $img.src = reader.result\n}\n··\n\n## 浏览器\n\n### Network\n\nget - Query String Parameters\npost - Form Data：Content-Type: application/x-www-form-urlencoded (默认)\npost - Request Payload：Content-Type:application/json;charset=UTF-8（jq 默认会把 data 转成查询字符串，如果先 JSON.stringify(data) 就是个对象）\n\n&2019/4/18\n'}}},i=a,o=t("2877"),s=Object(o["a"])(i,l,r,!1,null,null,null);n["default"]=s.exports}}]);
//# sourceMappingURL=chunk-2d0d7d7d.3edb220f.js.map