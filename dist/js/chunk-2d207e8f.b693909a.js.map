{"version":3,"sources":["webpack:///./src/pages/article/jsType/es6.vue?b4c4","webpack:///src/pages/article/jsType/es6.vue","webpack:///./src/pages/article/jsType/es6.vue?42e7","webpack:///./src/pages/article/jsType/es6.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,87MCR2W,I,YCOvWC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d207e8f.b693909a.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# es6\r\n\r\n## 概述\r\n\r\nECMAScript 6.0 版（简称 ES6）是 JavaScript 语言的下一代标准，已在 2015 年 6 月正式发布\r\n\r\n### ECMAScript\r\n\r\nECMAScript 和 JavaScript 的关系：\r\n\r\n!!\r\n1996 年 11 月，JavaScript 的创造者 Netscape 公司将 JavaScript 提交给标准化组织 ECMA，希望能成为国际标准\r\n次年，ECMA 规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版\r\n之所以不叫 JavaScript，有两个原因\r\n    一是商标，Java 是 Sun 公司的商标，只有 Netscape 公司可以合法使用，且 JavaScript 也是 Netscape 公司的商标\r\n    二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性\r\n因此 ECMAScript 是 JavaScript 的标准规格，JavaScript 是 ECMAScript 的一种实现，日常场合这两个词可以互换\r\n!!\r\n\r\n### ES2015\r\n\r\nECMAScript 2015（简称 ES2015）和 ES6 的关系：\r\n\r\n!!\r\n2011 年 ECMAScript 5.1 版发布后，就开始制定 6.0 版了\r\n但标准委员会为了更好的改进和发展，决定不再以 6.1、6.2 这种版本记号，改成以年份为标记\r\nES6 的第一个版本在 2015 年发布，正式名称就是《ECMAScript 2015 标准》\r\n因此 ES6 是个泛指，含义是 5.1 版以后的 JavaScript 下一代标准，包括 ES2015、ES2016、ES2017 等等\r\n!!\r\n\r\n## Promise\r\n\r\n### 概述\r\n\r\n异步编程的一种解决方案，简单说就是一个容器，里面保存一个异步操作的结果\r\n有三种状态：·pending·（进行中）、·fulfilled·（已成功）和·rejected·（已失败）\r\n·Promise·的构造函数接受一个函数，且有两个参数方法 ·resolve· 和 ·reject·\r\n·resolve·是成功时执行的函数，·reject·是失败时执行的函数\r\n若调用·resolve·和·reject·时带有参数将会传递给回调函数，·reject·通常传递·Error·对象的实例\r\n\r\n··js\r\nconst promise = new Promise((resolve, reject) => {\r\n    setTimeout(() => {\r\n        if (/* 异步操作成功 */){\r\n            resolve()\r\n        } else {\r\n            reject(new Error())\r\n        }\r\n    }, 1000)\r\n})\r\n··\r\n\r\n### then()\r\n\r\n·Promise.prototype.then()·：监听 Promise 的状态变化，接受两个回调函数作为参数，分别在成功和失败时执行\r\n\r\n··js\r\npromise.then(value => {\r\n    console.log('成功')\r\n}, error => {\r\n    console.log('失败')\r\n})\r\n··\r\n\r\nPromise 新建后回调函数会立即执行，·resolve· 和 ·reject· 异步执行：\r\n\r\n··js\r\nconst promise = new Promise((resolve, reject) => {\r\n    resolve('1')\r\n    console.log('2')\r\n})\r\npromise.then(res => console.log(res))\r\nconsole.log('3')\r\n\r\n// 2\r\n// 3\r\n// 1\r\n··\r\n\r\n·then·会返回的新的 Promise 实例。因此可以采用链式写法，且前一个·then·返回的值可作为后一个·then·的参数使用：\r\n··js\r\npromise.then(() => {\r\n    return 123\r\n}).then(res => {\r\n    console.log(res) // 123\r\n})\r\n··\r\n\r\n如果前一个·then·返回的还是一个 Promise 对象，这时后一个·then·就会监听该 Promise 的状态变化：\r\n\r\n··js\r\nconst p = new Promise(resolve => {\r\n    setTimeout(() => resolve('p'), 2000)\r\n})\r\nconst p1 = new Promise(resolve => {\r\n    setTimeout(() => resolve('p1'), 1000)\r\n})\r\np.then(res => {\r\n    console.log(res) // p （2 秒后触发）\r\n    return p1 // （p1 的状态 1 秒已改变）\r\n}).then(res => {\r\n    console.log(res) // p1 （上一个 then 触发完毕立即触发）\r\n})\r\n··\r\n\r\n如果·resolve·的参数是 Promise 对象，则·then·会变成监听那个 Promise 对象\r\n\r\n··js\r\nconst p1 = new Promise(function (resolve, reject) {\r\n  setTimeout(() => reject(new Error('fail')), 3000)\r\n})\r\nconst p2 = new Promise(function (resolve, reject) {\r\n  setTimeout(() => resolve(p1), 1000) // 1 秒后发现是传递 Promise 对象，所以 p2 的状态无效，改成由 p1 决定\r\n})\r\np2.then(result => {\r\n    console.log(result)\r\n}).catch(error => {\r\n    console.log(error) // Error: fail（3 秒后触发）\r\n})\r\n··\r\n\r\n### catch()\r\n\r\n·Promise.prototype.catch()·：发生错误时触发，即·.then(null, fn)·的别名\r\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获：\r\n\r\n··js\r\nconst p = new Promise((resolve, reject) => resolve('p'))\r\nconst p1 = new Promise((resolve, reject) => reject(new Error('p1')))\r\nconst p2 = new Promise((resolve, reject) => resolve('p1'))\r\np.then(res => {\r\n    return p1\r\n}).then(res => {\r\n    return p2\r\n}).then(res => {\r\n    console.log(res)\r\n}).catch(error => {\r\n    // 处理前面所有 Promise 中第一个产生的错误\r\n    console.log(error) // Error: p1\r\n})\r\n··\r\n\r\nPromise 内部的错误不会影响到 Promise 外部的代码：\r\n\r\n··js\r\nconst promise = new Promise((resolve, reject) => {\r\n    resolve(x + 2) // 报错，x 没有声明\r\n})\r\npromise.then(function() {\r\n    console.log('everything is great')\r\n})\r\nsetTimeout(() => { console.log(123) }, 2000)\r\n\r\n// Uncaught (in promise) ReferenceError: x is not defined\r\n// 123\r\n··\r\n\r\n### finally()\r\n\r\n·Promise.prototype.finally()·：不管 Promise 对象最后状态如何都会执行的操作，即：\r\n\r\n··js\r\npromise.finally(() => console.log(123))\r\n// 等同于\r\npromise.then(() => console.log(123), () => console.log(123))\r\n··\r\n\r\n具体实现：\r\n\r\n··js\r\nPromise.prototype.finally = function (callback) {\r\n    const P = this.constructor\r\n    return this.then(\r\n        value  => P.resolve(callback()).then(() => value),\r\n        reason => P.resolve(callback()).then(() => { throw reason })\r\n    )\r\n}\r\n··\r\n\r\n### Promise.all()\r\n\r\n将多个 Promise 实例包装成一个新的 Promise 实例，接受一个由 Promise 对象数组作为参数\r\n\r\n··js\r\n// p1、p2、p3 都是 Promise 对象\r\nconst p = Promise.all([p1, p2, p3])\r\np.then(list => {\r\n    // ...\r\n}).catch(error => {\r\n    // ...\r\n})\r\n··\r\n\r\n上面的代码中·p·的状态由·p1 p2 p3·决定\r\n如果都成功·p·才会触发·then·，并会将·p1 p2 p3·的返回值组成数组传给·p·\r\n如果有一个失败·p·就会触发·catch·，并会将第一个失败的返回值会传递给·p·\r\n注意，如果参数自己定义并触发了·catch·方法，并不会触发·Promise.all()·的·catch·，而是触发·then·\r\n\r\n### Promise.race()\r\n\r\n用法同·Promise.all()·，·p·的状态取决于·p1 p2 p3·中第一个改变的状态，第一个改变的返回值会传递给·p·\r\n\r\n··js\r\n// 超时处理：5 秒内无结果就会触发 catch\r\nconst p = Promise.race([\r\n    fetch('/resource-that-may-take-a-while'),\r\n    new Promise((resolve, reject) => {\r\n        setTimeout(() => reject(new Error('request timeout')), 5000)\r\n    })\r\n])\r\n\r\np\r\n.then(console.log)\r\n.catch(console.error)\r\n··\r\n\r\n### Promise.allSettled()\r\n\r\n用法同·Promise.all()·，不管·p1 p2 p3·的状态，都触发完毕·p·就会触发·then·，且参数为所有结果的返回值组成的数组\r\n该数组的格式为固定格式的对象数组，形如：\r\n··js\r\n[\r\n    { status: \"fulfilled\", value: 1 }, // 成功\r\n    { status: \"rejected\", reason: 2 } // 失败\r\n]\r\n··\r\n\r\n··js\r\n// 输出失败的请求\r\nconst p = Promise.allSettled([ fetch('index.html'), fetch('https://does-not-exist/') ])\r\np.then(list => {\r\n    list.filter(item => item.status === 'rejected').map(item => item.reason)\r\n})\r\n··\r\n\r\n### Promise.any()\r\n\r\n用法同·Promise.all()·，·p1 p2 p3·只要有一个成功就触发·then·，都失败才触发·catch·，和·Promise.all()·相反\r\n注意·catch·接受的错误数组是个由·AggregateError·组成的数组\r\n\r\n### Promise.resolve()\r\n\r\n将参数转为 Promise 对象，参数分成四种情况：\r\n\r\n#### Promise 实例将不做任何修改直接返回这个实例\r\n\r\n#### 不传参数直接·resolve·一个 Promise 对象\r\n\r\n#### 定义了·then·方法的对象会立即执行\r\n\r\n··js\r\nconst p = Promise.resolve({\r\n    then (resolve, reject) {\r\n        resolve(123)\r\n    }\r\n})\r\np.then(console.log) // 123\r\n··\r\n\r\n#### 未定义了·then·方法的对象或其他值直接·resolve·这个值\r\n\r\n··js\r\nPromise.resolve('foo')\r\n// 等同于\r\nnew Promise(resolve => resolve('foo'))\r\n··\r\n\r\n注意立即·resolve()·的 Promise 对象，是在本轮事件循环结束时执行，而不是在下一轮的开始时\r\n\r\n··js\r\nsetTimeout(() => console.log(3))\r\nPromise.resolve().then(() => console.log(2)\r\nconsole.log(1)\r\n// 1\r\n// 2\r\n// 3\r\n··\r\n\r\n### Promise.reject()\r\n\r\n将参数转为 Promise 对象，并直接·reject·这个值，不管参数是什么\r\n\r\n··js\r\nconst p = Promise.reject('出错了')\r\n// 等同于\r\nconst p = new Promise((resolve, reject) => reject('出错了'))\r\n··\r\n\r\n### Promise.try()\r\n\r\n有时候不知道或者不想区分函数·f·是同步还是异步操作，想用 Promise 统一处理\r\n但如果·f·是同步函数则会在本轮事件循环的末尾执行，本意是让同步函数同步执行，异步函数异步执行：\r\n\r\n··js\r\nconst f = () => console.log('now')\r\nPromise.resolve().then(f)\r\nconsole.log('next')\r\n// next\r\n// now\r\n··\r\n\r\n·try·方法就可以做到：\r\n\r\n··js\r\nconst f = () => console.log('now')\r\nPromise.try(f)\r\nconsole.log('next')\r\n// now\r\n// next\r\n··\r\n\r\n@@\r\n[ECMAScript 6 入门](http://es6.ruanyifeng.com/)\r\n@@\r\n\r\n&2020/06/06\r\n`\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./es6.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./es6.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./es6.vue?vue&type=template&id=318e65be&\"\nimport script from \"./es6.vue?vue&type=script&lang=js&\"\nexport * from \"./es6.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}