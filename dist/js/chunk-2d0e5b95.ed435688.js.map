{"version":3,"sources":["webpack:///./src/pages/article/js/grammar.vue?1af8","webpack:///src/pages/article/js/grammar.vue","webpack:///./src/pages/article/js/grammar.vue?9ab2","webpack:///./src/pages/article/js/grammar.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"uHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,+maCR+W,I,YCO3WC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d0e5b95.ed435688.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# 语法\r\n\r\n## this\r\n\r\n·this·返回当前对象\r\n\r\n### 全局环境指向 window\r\n\r\n··js\r\nthis // window\r\n··\r\n\r\n### 构造函数指向实例\r\n\r\n··js\r\nvar Obj = function (p) {\r\n    this.p = p\r\n}\r\nvar o = new Obj('Hello World!')\r\no.p // \"Hello World!\"\r\n··\r\n\r\n### 对象方法中指向该对象\r\n\r\n··js\r\nvar A = {\r\n    name: '张三',\r\n    describe: function () {\r\n        return this.name\r\n    }\r\n}\r\nA.describe() // \"张三\"\r\n  \r\nvar B = {\r\n    name: '李四'\r\n}\r\nB.describe = A.describe\r\nB.describe() // \"李四\"\r\n··\r\n\r\n### 改变指向\r\n\r\n··js\r\nvar obj = {\r\n    foo: function () {\r\n        console.log(this)\r\n    }\r\n}\r\n\r\n// 情况一\r\n(obj.foo = obj.foo)() // window\r\n// 情况二\r\n(false || obj.foo)() // window\r\n// 情况三\r\n(1, obj.foo)() // window\r\n··\r\n\r\nJavaScript 引擎内部·obj·和·obj.foo·储存在两个内存地址，称为地址 A 和 B\r\n·obj.foo()·调用时从地址 A 调用地址 B，因此地址 B 的运行环境是地址 A，·this·指向·obj·\r\n但上面三种情况都是直接取出地址 B 进行调用，这样运行环境就是全局环境\r\n所以要注意下面类似的情况：\r\n\r\n··js\r\nvar o = new Object()\r\no.f = function () {\r\n    console.log(this === o)\r\n}\r\n\r\n// jQuery 的写法\r\n$('#button').on('click', o.f) // false\r\n// 此时 this 不再指向 o 对象，而是指向按钮的 DOM 对象\r\n··\r\n\r\n### 对象方法的第一层\r\n\r\n#### 对象方法嵌套\r\n\r\n··js\r\nvar a = {\r\n    p: 'a',\r\n    b: {\r\n        p: 'b',\r\n        m: function () {\r\n            console.log(this.p)\r\n        }\r\n    }\r\n}\r\n\r\na.b.m() // \"b\"\r\n··\r\n\r\n#### 对象方法嵌套方法实际是在全局中调用\r\n\r\n内层的·this·不指向外部，而指向顶层对象·window·\r\n\r\n··js\r\nvar a = {\r\n    p: 'a',\r\n    b: function() {\r\n        setTimeout(function () {\r\n            console.log(this.p)\r\n        })\r\n    }\r\n}\r\n\r\na.b() // window\r\n··\r\n\r\n常见的做法：用变量固定·this·的值，或使用箭头函数\r\n\r\n### F.p.call()\r\n\r\n·Function.prototype.call(obj, ...arg)·：指定函数内部·this·的指向并调用该函数\r\n第一个参数为要指向的对象，后面的参数为函数调用时所需的参数\r\n如果参数为空、·null·和·undefined·，则默认传入全局对象·window·\r\n\r\n··js\r\nvar obj = {}\r\n\r\nvar f = function () {\r\n    return this\r\n}\r\n\r\nf() === window // true\r\nf.call(obj) === obj // true\r\n··\r\n\r\n如果参数是一个原始值则会自动转成对应的包装对象\r\n\r\n··js\r\nvar f = function () {\r\n    console.log(this)\r\n}\r\n  \r\nf.call(5) // Number {[[PrimitiveValue]]: 5}\r\n··\r\n\r\n#### 调用对象的原生方法防止被覆盖\r\n\r\n··js\r\nvar obj = {}\r\nobj.hasOwnProperty = function () {\r\n    return true\r\n}\r\nObject.prototype.hasOwnProperty.call(obj, 'toString') // false\r\n··\r\n\r\n### F.p.apply()\r\n\r\n·Function.prototype.apply(obj, [...arg])·：作用和·call()·一样，区别就是第二个参数是个数组\r\n\r\n#### 找出数组最大元素\r\n\r\n··js\r\nvar a = [10, 2, 4, 15, 9]\r\nMath.max.apply(null, a) // 15\r\n··\r\n\r\n#### 将数组的空元素变为 undefined\r\n\r\n空元素和·undefined·的区别详见·js标准库 - array - es6 - 数组的空位·\r\n\r\n··js\r\nArray.apply(null, ['a', ,'b'])\r\n// [ 'a', undefined, 'b' ]\r\n··\r\n\r\n### F.p.bind()\r\n\r\n·Function.prototype.bind(obj, ...arg)·：将方法内的·this·绑定到某个对象，然后返回一个新方法，参数用法同·call()·\r\n\r\n#### 直接赋值对象的方法\r\n\r\n··js\r\nvar obj = {\r\n    a: 'obj',\r\n    b: function () {\r\n        console.log(this.a)\r\n    }\r\n}\r\n\r\nvar f1 = obj.b\r\nf1() // undefined\r\n\r\nvar f2 = obj.b.bind(obj)\r\nf2() // \"obj\"\r\n··\r\n\r\n#### 使用参数\r\n\r\n··js\r\nvar add = function (x, y) {\r\n    return x * this.m + y * this.n\r\n}\r\n\r\nvar obj = {\r\n    m: 2,\r\n    n: 2\r\n}\r\n  \r\nvar newAdd = add.bind(obj, 5) // 将第一个参数 x 绑定成 5，只要再接受一个参数 y 即可\r\nnewAdd(5) // 20\r\n··\r\n\r\n#### 每次返回一个新函数\r\n\r\n所以监听事件：\r\n\r\n··js\r\nel.addEventListener('click', o.m.bind(o))\r\nel.removeEventListener('click', o.m.bind(o)) // 移除无效\r\n··\r\n\r\n需改成：\r\n\r\n··js\r\nvar listener = o.m.bind(o)\r\nel.addEventListener('click', listener)\r\nel.removeEventListener('click', listener)\r\n··\r\n\r\n## 包装对象\r\n\r\n### 介绍\r\n\r\n数值、字符串、布尔值通过构造函数生成的对象即为包装对象\r\n设计目的是使得“对象”这种类型可以覆盖 JavaScript 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法\r\n三种包装对象各自提供了许多实例方法，而它们共同具有、从·Object·对象继承的方法是·valueOf()·和·toString()·\r\n·valueOf()·返回包装对象实例的原始类型的值\r\n\r\n··js\r\nnew Number(123).valueOf()  // 123\r\nnew String('abc').valueOf() // \"abc\"\r\nnew Boolean(true).valueOf() // true\r\n··\r\n\r\n·toString()·返回对应的字符串形式\r\n\r\n··js\r\nnew Number(123).toString() // \"123\"\r\nnew String('abc').toString() // \"abc\"\r\nnew Boolean(true).toString() // \"true\"\r\n··\r\n\r\n### 原始类型的自动转换\r\n\r\n当原始类型的值调用包装对象才有的属性或方法时，会自动转为包装对象实例，并在使用后立刻销毁实例\r\n\r\n··js\r\n'abc'.length // 3\r\n// abc 本身是字符串而不是对象，不能调用 length 属性\r\n// 但使用时自动将其转为包装对象，在这个对象上调用 length 属性。调用结束后，这个临时对象就会被销毁\r\n··\r\n\r\n调用结束后，包装对象实例会自动销毁\r\n这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性\r\n如果要为字符串添加属性，只有在它的原型对象·String.prototype·上定义\r\n\r\n··js\r\nvar s = 'Hello World'\r\ns.x = 123\r\ns.x // undefined\r\n··\r\n\r\n## 数据类型转换\r\n\r\n### 介绍\r\n\r\nJavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值\r\n虽然变量的数据类型是不确定的，但是数据运算是有要求的。若与预期不符就会自动转换类型\r\n例如减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值\r\n\r\n··js\r\n'4' - '3' // 1\r\n··\r\n\r\n强制转换：主要指使用·Number() String() Boolean()·手动转换成数字、字符串或者布尔值\r\n\r\n### Number()\r\n\r\n··js\r\n// 数值：不变\r\nNumber(324) // 324\r\n\r\n// 字符串：如果可以解析为数值则转换为相应的数值，否则返回 NaN，空字符串转为 0\r\n// Number 和 parseInt 都会自动过滤字符串前后的空格类型字符\r\nNumber('324') // 324\r\nNumber('324abc') // NaN\r\nparseInt('324abc') // 324（类似的 parseInt）\r\nNumber('') // 0\r\n\r\n// 布尔值：true 转成 1，false 转成 0\r\nNumber(true) // 1\r\nNumber(false) // 0\r\n\r\n// undefined：转成 NaN\r\nNumber(undefined) // NaN\r\n\r\n// null：转成 0\r\nNumber(null) // 0\r\n\r\n// 对象：返回 NaN，除非是包含单个数值的数组（先后调用了对象的 valueOf() 和 toString() 再使用 Number()）\r\nNumber({ a: 1 }) // NaN\r\nNumber([1, 2, 3]) // NaN\r\nNumber([5]) // 5\r\n··\r\n\r\n### String()\r\n\r\n··js\r\n// 原始类型值\r\nString(123) // \"123\"\r\nString('abc') // \"abc\"\r\nString(true) // \"true\"\r\nString(undefined) // \"undefined\"\r\nString(null) // \"null\"\r\n\r\n// 对象\r\n/*\r\n先调用了对象的 toString()\r\n    若返回原始类型值则直接使用 String()\r\n    若返回对象则继续使用 valueOf()，\r\n        若返回原始类型值则直接使用 String()\r\n        若返回对象则报错（自定义 valueOf() 和 String() 返回对象的情况）\r\n*/\r\nString({ a: 1 }) // \"[object Object]\"\r\nString([1, 2, 3]) // \"1,2,3\"\r\n··\r\n\r\n### Boolean()\r\n\r\n··js\r\n// 原始类型值\r\nBoolean(true) // true\r\nBoolean(false) // false\r\n// 以下五个值为 false，其他都为 true\r\nBoolean(undefined) // false\r\nBoolean(null) // false\r\nBoolean(0) // false（包扩 -0 和 +0）\r\nBoolean(NaN) // false\r\nBoolean('') // false\r\n\r\n// 对象始终为 true\r\nBoolean({}) // true\r\nBoolean([]) // true\r\nBoolean(new Boolean(false)) // true\r\n··\r\n\r\n### 自动转换为布尔值\r\n\r\n对非布尔值类型的数据求布尔值，自动使用·Boolean()·转换\r\n注意对于对象会先用·String()·再使用·Boolean()·转换比较\r\n\r\n··js\r\nif ('abc') {\r\n    console.log('hello')\r\n}\r\n// \"hello\"\r\n\r\n[] == false // true（相当于 '' == false）\r\n({}) == false // false（相当于 '[object object] == false'）（注意行首是大括号则作为代码块执行了，加圆括号解释为对象）\r\n({valueOf: function () { return false }}) == false // true\r\n··\r\n\r\n### 自动转换为字符串\r\n\r\n只在加法·+·的情况下，运算符两边有值且任意一边是字符串就转为字符串：\r\n\r\n··js\r\n'5' + 1 // '51'\r\n1 + '5' // '15'\r\n'5' + true // \"5true\"\r\n'5' + false // \"5false\"\r\n'5' + {} // \"5[object Object]\"\r\n'5' + [] // \"5\"\r\n'5' + function () {} // \"5function () {}\"\r\n'5' + undefined // \"5undefined\"\r\n'5' + null // \"5null\"\r\n··\r\n\r\n### 自动转换为数值\r\n\r\n加法·+·两边都不是字符串 或 非加法·+·运算符 或 一元运算符（即·+·和·-·） 的情况下，对于非数值调用·Number()·自动转换：\r\n\r\n··js\r\nnull + 1 // 1\r\nundefined + 1 // NaN\r\n\r\n'5' - '2' // 3\r\n'5' * '2' // 10\r\ntrue - 1  // 0\r\nfalse - 1 // -1\r\n'1' - 1   // 0\r\n'5' * []    // 0\r\nfalse / '5' // 0\r\n'abc' - 1   // NaN\r\n\r\n+ 'abc' // NaN\r\n- 'abc' // NaN\r\n+ true // 1\r\n- false // 0\r\n+ { foo: 'bar' } // NaN\r\n- [1, 2, 3] // NaN\r\n+ [] // 0\r\n··\r\n\r\n## JSON\r\n\r\n### JSON 格式\r\n\r\nJSON 格式（JavaScript Object Notation）是一种用于数据交换的文本格式\r\n2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式\r\n书写规范：\r\n\r\n!!\r\n复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象\r\n原始类型的值只有字符串、数值（十进制）、布尔值和·null·\r\n    （不能使用·NaN·, ·Infinity·, ·-Infinity·和·undefined·）\r\n字符串必须使用双引号表示，不能使用单引号\r\n对象的键名必须使用双引号\r\n数组或对象最后一个成员的后面，不能加逗号\r\n!!\r\n\r\n··js\r\n[\"one\", \"two\", \"three\"]\r\n\r\n{ \"one\": 1, \"two\": 2, \"three\": 3 }\r\n\r\n{\"names\": [\"张三\", \"李四\"] }\r\n\r\n[{ \"name\": \"张三\"}, {\"name\": \"李四\"}]\r\n··\r\n\r\n### JSON 对象\r\n\r\n·JSON·对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：·JSON.stringify()·和·JSON.parse()·\r\n\r\n### JSON.stringify()\r\n\r\n将 JSON 对象转为 JSON 字符串：·JSON.stringify(obj, propArr/fn, format)·\r\n\r\n··js\r\nJSON.stringify('abc') // \"\"abc\"\"\r\nJSON.stringify(1) // \"1\"\r\nJSON.stringify(false) // \"false\"\r\nJSON.stringify([]) // \"[]\"\r\nJSON.stringify({}) // \"{}\"\r\n\r\nJSON.stringify([1, \"false\", false])\r\n// '[1,\"false\",false]'\r\n\r\nJSON.stringify({ name: \"张三\" })\r\n// '{\"name\":\"张三\"}'\r\n\r\n// 不符合规范的值会被忽略\r\nvar obj = {\r\n    a: undefined,\r\n    b: function () {}\r\n}\r\nJSON.stringify(obj) // \"{}\"\r\n··\r\n\r\n### 第二个参数\r\n\r\n第二个参数表示只转换指定的属性（只在转换对象时有效，对数组无效）：\r\n\r\n··js\r\nvar obj = {\r\n    'prop1': 'value1',\r\n    'prop2': 'value2',\r\n    'prop3': 'value3'\r\n}\r\n\r\nJSON.stringify(obj, ['prop1', 'prop2'])\r\n// \"{\"prop1\":\"value1\",\"prop2\":\"value2\"}\"\r\n··\r\n\r\n还可以是一个函数更改返回值（该函数会递归处理每个键值对，且第一个是对象本身）：\r\n\r\n··js\r\nJSON.stringify({ a: 1, b: 2 }, function (key, value) {\r\n    if (typeof value === \"number\") value = 2 * value\r\n    return value\r\n})\r\n// '{\"a\": 2,\"b\": 4}'\r\n\r\nvar o = { a: 1 }\r\nJSON.stringify(o, function (key, value) {\r\n    if (typeof value === 'object') return {b: 2}\r\n    return value * 2\r\n})\r\n// \"{\"b\": 4}\"\r\n··\r\n\r\n### 第三个参数\r\n\r\n第三个参数表示增加字符串的可读性，在每个属性前面添加指定的字符\r\n传入数字（·1-10·）表示空格的个数，传入字符串（长度·<=10·）表示该字符串\r\n\r\n··js\r\nJSON.stringify({ p1: 1, p2: { a: 1, b: [1, 2] } }, null, 4)\r\n/*\r\n\"{\r\n  \"p1\": 1,\r\n  \"p2\": {\r\n    \"a\": 1,\r\n    \"b\": [\r\n      1,\r\n      2\r\n    ]\r\n  }\r\n}\"\r\n*/\r\n\r\nJSON.stringify({ p1: 1, p2: { a: 1, b: [1, 2] } }, null, '|---')\r\n/*\r\n\"{\r\n|---\"p1\": 1,\r\n|---\"p2\": {\r\n|---|---\"a\": 1,\r\n|---|---\"b\": [\r\n|---|---|---1,\r\n|---|---|---2\r\n|---|---]\r\n|---}\r\n}\"\r\n*/\r\n··\r\n\r\n### 参数对象 toJSON\r\n\r\n如果参数对象有自定义的·toJSON·方法，那么·JSON.stringify()·会直接使用这个方法的返回值作为参数\r\n\r\n··js\r\nvar user = {\r\n    lastName: '张',\r\n    firstName: '三',\r\n    toJSON: function () {\r\n        return {\r\n            name:  this.firstName + this.lastName\r\n        }\r\n    }\r\n}\r\nJSON.stringify(user)\r\n// \"{\"name\":\"张三\"}\"\r\n\r\nJSON.stringify(new Date) // Date 也有定义过\r\n// \"\"2015-01-01T00:00:00.000Z\"\"\r\n\r\n// 转换正则\r\nRegExp.prototype.toJSON = RegExp.prototype.toString\r\nJSON.stringify(/foo/) // \"\"/foo/\"\"\r\n··\r\n\r\n### JSON.parse()\r\n\r\n将 JSON 字符串转换成对应的值，即·JSON.stringify()·的逆操作\r\n\r\n··js\r\nJSON.parse('{}') // {}\r\nJSON.parse('true') // true\r\nJSON.parse('\"foo\"') // \"foo\"\r\nJSON.parse('[1, 5, \"false\"]') // [1, 5, \"false\"]\r\nJSON.parse('null') // null\r\n··\r\n\r\n可以传入一个函数作为第二个参数，用法与·JSON.stringify()·类似\r\n\r\n··js\r\nJSON.parse('{\"a\": 1, \"b\": 2}', function (key, value) {\r\n    if (key === 'a') return value + 10\r\n    return value\r\n})\r\n// {a: 11, b: 2}\r\n··\r\n\r\n## window\r\n\r\n### window\r\n\r\n·window·对象指当前的浏览器窗口，浏览器环境的所有全局变量都是·window·对象的属性\r\n\r\n### document\r\n\r\n·document·对象是文档的根节点，即整个网页，·window.document·属性就指向这个对象\r\n有·document.head·和·document.body·等，·document.documentElement·代表 html 根节点\r\n\r\n3 种节点\r\n元素：nodeType = 1\r\n属性：nodeType = 2\r\n文本：nodeType = 3\r\n\r\n其他\r\n注释：nodeType = 8\r\n文档：nodeType = 9\r\n\r\nnodeType\r\n\r\n%%\r\n| 序号 | 类型 | 描述 |\r\n| :-: | :-: | :- |\r\n| 1 | Element | 元素 |\r\n| 2 | Attr | 属性 |\r\n| 3 | Text | 文本 |\r\n| 4 | CDATASection | 文档中的 CDATA 部分（不会由解析器解析的文本） |\r\n| 5 | EntityReference | 实体引用 |\r\n| 6 | Entity | 实体 |\r\n| 7 | ProcessingInstruction | 处理指令 |\r\n| 8 | Comment | 注释 |\r\n| 9 | Document | 整个文档 |\r\n| 10 | DocumentType | 向为文档定义的实体提供接口，即html的开头&lt;!DOCTYPE html&gt; |\r\n| 11 | DocumentFragment | 轻量级的 Document 对象，能够容纳文档的某个部分 |\r\n| 12 | Notation | DTD 中声明的符号 |\r\n%%\r\n\r\n### location\r\n\r\n·window.location·返回一个·location·对象，用于获取窗口当前的 URL 信息\r\n等同于·document.location·对象，在·iframe·中获取也是如此\r\n\r\n··js\r\nwindow.location === document.location   // true\r\n··\r\n\r\n## 宽高位置\r\n\r\n### window\r\n\r\n!!\r\nwindow.innerWidth、window.innerHeight：网页在当前窗口中可见部分的宽高，包括滚动条\r\nwindow.outerWidth、window.outerHeight：整个浏览器的宽高\r\nwindow.screen.width、window.screen.height：整个屏幕的宽高\r\nwindow.screen.availWidth、window.screen.availHeight：整个屏幕可利用的宽高，即不包括任务栏\r\nwindow.screenTop、window.screenLeft：浏览器窗口距离屏幕顶部和左侧的距离\r\n!!\r\n\r\n### element\r\n\r\n!!\r\nel.clientWidth、el.clientHeight：元素可视部分的宽高，包括·padding·，不包括·border·和滚动条\r\nel.clientTop、el.clientLeft：元素·border-top·和·border-left·的宽度\r\nel.offsetWidth、el.offsetHeight：元素可视部分的宽高，包括·padding·和·border·和滚动条\r\nel.offsetTop、el.offsetLeft：元素相对于父级元素的·top·和·left·值\r\n    该父级元素需设置非·static·定位，否则会一直往上找到符合条件的父元素直到·body·\r\nel.scrollWidth、el.scrollHeight：元素的滚动内容宽高，包括·padding·，不包括·border·和滚动条\r\n    如果是获取·body·的宽高，若其宽高小于浏览器窗口的宽高则还是按浏览器窗口的宽高\r\nel.scrollTop、el.scrollLeft：元素被卷去的·top和·left·值，可手动赋值修改\r\n!!\r\n\r\n### event 待\r\n\r\n!!\r\nclientX / clientY：鼠标位置相对于浏览器内容区域左上角的水平垂直偏移量，该参照点会随着滚动条的移动而移动\r\npageX / pageY：鼠标位置相对于浏览器内容区域左上角的水平垂直偏移量，不会随着滚动条而变动\r\nscreenX / screenY：鼠标位置相对于屏幕左上角的水平垂直偏移量\r\n!!\r\n\r\n### 其他\r\n\r\n谜之 js\r\n\r\n··js\r\n!![]   // true\r\n[] == false // true\r\n[0] == false // true\r\n\r\n+ []    // 0\r\n+ {}    // NaN\r\n[] + {} // \"[object Object]\"\r\n{} + [] // 0\r\n\r\n// 非 0 的数可以转换成 true，但 true 只能转换成 1\r\n!!2 // true\r\ntrue == 1   // true\r\ntrue == 2   // false\r\n\r\n// 判断数组是否为空\r\narr.length === 0\r\nJSON.stringify(arr) === '[]'\r\n\r\n// 判断对象是否为空\r\nObject.keys(obj).length === 0\r\nJSON.stringify(obj) === '{}'\r\n··\r\n\r\n### this\r\n\r\n··js\r\nvar a = 'a'\r\nvar obj = {\r\n    a: 1,\r\n    b: this.a,  // 'a'\r\n    c: function () {\r\n        console.log(this.a) // 1\r\n    },\r\n    d: function () {\r\n        var e = function () {\r\n            console.log(this.a)\r\n        }\r\n        e() // 'a'\r\n    }\r\n}\r\n··\r\n\r\n## 其他\r\n\r\n### 判断数组或对象为空\r\n\r\n简单的和 false 比较是不准确的\r\n\r\n··js\r\n{} == false // Uncaught SyntaxError: Unexpected token ==\r\n{} === false // Uncaught SyntaxError: Unexpected token ===\r\n!{} // false\r\n!{a:1} // false\r\n\r\n[] == false // true\r\n[] === false // false\r\n[0] == false // true\r\n[1] == false // false\r\n![] // false\r\n![0] // false\r\n![1] // false\r\n··\r\n\r\n1、length\r\n\r\n··js\r\narr.length === 0\r\nObject.keys(obj).length === 0\r\n··\r\n\r\n2、JSON.stringify\r\n\r\n··js\r\nJSON.stringify(arr) === '[]'\r\nJSON.stringify(obj) === '{}'\r\n··\r\n\r\n## 待\r\n\r\n··js\r\n// 调用函数只会作用于原来的地方，在这个地方调用，并不是把函数拿过来用\r\nvar a = 'a'\r\nfunction fnA () {\r\n    console.log(a)\r\n}\r\nfunction fnB () {\r\n    var a = 66\r\n    fnA()\r\n}\r\nfnB()\r\n\r\n// 原生 dataset 会改变标签里面的 data 值\r\n// jq.data 不会改变标签里面的 data 值\r\n\r\n// 时间戳从页面加载开始计时 e.timeStamp\r\n// offsetX 相对于元素左上角边框以内\r\n// pageX 相对于文档左上角\r\n// clientX 相对于浏览器左上角\r\n// screenX 相对于屏幕左上角\r\n··\r\n\r\n### 运算符优先级\r\n\r\n[参照 MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table)\r\n\r\n&2019/9/17\r\n`\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./grammar.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./grammar.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./grammar.vue?vue&type=template&id=1ff490e3&\"\nimport script from \"./grammar.vue?vue&type=script&lang=js&\"\nexport * from \"./grammar.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}