{"version":3,"sources":["webpack:///./src/pages/article/jsType/regexp.vue?bb5c","webpack:///src/pages/article/jsType/regexp.vue","webpack:///./src/pages/article/jsType/regexp.vue?f32c","webpack:///./src/pages/article/jsType/regexp.vue"],"names":["render","_vm","this","_h","$createElement","_c","_self","domProps","_s","format","text","staticRenderFns","component"],"mappings":"yHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,SAAS,CAAC,UAAYN,EAAIO,GAAGP,EAAIQ,OAAOR,EAAIS,WAClJC,EAAkB,GCItB,GACE,KADF,WAEI,MAAJ,CACM,KAAN,o2RCR8W,I,YCO1WC,EAAY,eACd,EACAZ,EACAW,GACA,EACA,KACA,KACA,MAIa,aAAAC,E","file":"js/chunk-2d0ba396.92ebf782.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{domProps:{\"innerHTML\":_vm._s(_vm.format(_vm.text))}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div v-html=\"format(text)\"></div>\r\n</template>\r\n\r\n<script>\r\nexport default {\r\n    data () {\r\n        return {\r\n            text: `\r\n# regexp\r\n\r\n## 概述\r\n\r\n字面量形式新建，以斜杠开始和结束：\r\n\r\n··js\r\nvar reg = /xyz/g\r\n··\r\n\r\n·RegExp·构造函数新建，第一个是正则内容，第二个是修饰符：\r\n··js\r\nvar reg = new RegExp('xyz', 'g')\r\n··\r\n\r\n## 规则\r\n\r\n### 字符类\r\n\r\n!!\r\n^：表示字符串应以什么开始，注意只在第一个位置才有效\r\n$：表示字符串应以什么结束，注意只在最后一个位置才有效\r\n|：或关系，即·/cat|dog/·表示匹配·cat·或·dog·\r\n\\\\：转义符，以匹配元字符本身，需要转义的字符有：·. ^ $ [ { ( ) * + ? | \\\\ /·\r\n    **注意**，若使用·new RegExp()·则需要用两个·\\\\·，因为字符串内部会先转义一次\r\n!!\r\n\r\n### 范围匹配\r\n\r\n指定一段范围使用·[]·表示，比如·[xyz]·表示 x、y、z 之中任选一个匹配，·[210]·表示2、1、0 之中任选一个匹配\r\n!!\r\n^：在方括号内以·^·开头表示除了方括号内的字符都可以匹配，比如·[^xyz]·表示除了 x、y、z 之外都可以匹配\r\n    **注意**·^·只在第一个位置才有效，否则就是字面含义\r\n-：在方括号内连续的字符可用·-·连接，比如所有数字字母可以写成·[0-9a-zA-Z]·\r\n    **注意**·[1-30]·不是从 1 到 30，而是 1 到 3 和 0\r\n!!\r\n\r\n### 重复匹配\r\n\r\n!!\r\n\\\\{n}：n 次\r\n\\\\{n,}：n 到无限次\r\n\\\\{n,m}：n 到 m 次\r\n?：0 或 1 次，等同于·{0, 1}·\r\n*：0 到无限次，等同于·{0,}·\r\n+：1 到无限次，等同于·{1,}·\r\n*?：0 到无限次，一旦条件满足就不再匹配\r\n+?：1 到无限次，一旦条件满足就不再匹配\r\n!!\r\n\r\n### 预定义\r\n\r\n!!\r\n\\\\d：匹配数字，相当于·[0-9]·\r\n\\\\D：匹配非数字，相当于·[^0-9]·\r\n\\\\w：匹配字母、数字和下划线，相当于·[A-Za-z0-9_]·\r\n\\\\W：匹配非字母、数字和下划线，相当于·[^A-Za-z0-9_]·\r\n\\\\s：匹配空格字符，相当于·[ \\\\t\\\\r\\\\n\\\\v\\\\f]·\r\n\\\\S：匹配非空格字符，相当于·[^ \\\\t\\\\r\\\\n\\\\v\\\\f]·\r\n\\\\b：匹配单词的边界，即单词的前或后只能是·-·或空格或没有字符\r\n\\\\B：匹配非单词边界，即在词的内部\r\n.：匹配除回车·\\\\r·、换行·\\\\n·、行分隔符·\\\\u2028·和段分隔符·\\\\u2029·以外的所有字符\r\n    若加上修饰符·s·将指代任意字符，比如·/c.t/s·表示 c 和 t 之间任意一个字符都可以，包括·\\\\n·\r\n    注意码点大于·0xFFFF·的 Unicode 字符，点字符不能正确匹配，会认为是两个字符，需加上·u·修饰符才能正确识别\r\n!!\r\n\r\n··js\r\n// \\\\b 的例子\r\nvar res = /\\\\bworld/.test('hello world') // true\r\nvar res = /\\\\bworld/.test('hello-world') // true\r\nvar res = /\\\\bworld/.test('helloworld') // false\r\n\r\n// \\\\B 的例子\r\nvar res = /\\\\Bworld/.test('hello-world') // false\r\nvar res = /\\\\Bworld/.test('helloworld') // true\r\n··\r\n\r\n### 特殊字符\r\n\r\n对一些不能打印的特殊字符的表示\r\n\r\n!!\r\n\\\\cX：匹配·Ctrl-[X]·，·X·是·A-Z·中任一个字母，用来匹配控制字符\r\n\\\\[\\\\b]：匹配退格键(U+0008)，注意不是·\\\\b·\r\n\\\\n：匹配换行键\r\n\\\\r：匹配回车键\r\n\\\\t：匹配制表符 tab（U+0009）\r\n\\\\v：匹配垂直制表符（U+000B）\r\n\\\\f：匹配换页符（U+000C）\r\n\\\\0：匹配·null·字符（U+0000）\r\n\\\\xhh：匹配一个以两位十六进制数（·\\\\x00·-·\\\\xFF·）表示的字符\r\n\\\\uhhhh：匹配一个以四位十六进制数（·\\\\u0000·-·\\\\uFFFF·）表示的 Unicode 字符\r\n!!\r\n\r\n### 修饰符\r\n\r\n!!\r\ng：全局匹配，默认只匹配一次，加上·g·将匹配所有符合条件的结果\r\ni：不区分字母的大小写，默认是区分大小写的\r\nm：多行模式，让·^·和·$·可匹配行首和行尾，即会识别换行符·\\\\n·\r\ns：将·.·字符提升为所有字符\r\ny：粘连匹配，与·g·类似也是全局匹配，·g·是剩余位置中存在匹配就可以，·y·是匹配必须从剩余的第一个位置开始\r\nu：Unicode 模式，用来正确处理大于·\\\\uFFFF·的 Unicode 字符，即会正确处理四个字节的 UTF-16 编码\r\n!!\r\n··js\r\n// m\r\nvar res = /^b/m.test('a\\\\nb') // true\r\nvar res = /world$/m.test('hello world\\\\n') // true\r\n\r\n// y\r\nvar str = 'aaa_aa_a'\r\nvar g = /a+/g\r\nvar y = /a+/y\r\n// 第一次行为相同，都剩余 _aa_a\r\ng.exec(str) // [\"aaa\"]\r\ny.exec(str) // [\"aaa\"]\r\n// 第二次：g 在剩余的字符串中匹配到 aa，而 y 必须从头开始匹配，第一个字符串是下划线，所以匹配失败\r\ng.exec(str) // [\"aa\"]\r\ny.exec(str) // null\r\n\r\n// 最后一个 a 因为不是出现在下一次匹配的头部所以不会被替换\r\n'aaxa'.replace(/a/gy, '-') // '--xa'\r\n··\r\n\r\n### 组匹配\r\n\r\n·()·表示分组匹配\r\n\r\n··js\r\nvar res = /(fred){2}/.test('fredfred') // true\r\n'abc'.replace(/(.)b(.)/, '$1+$2') // 'a+c'\r\n··\r\n\r\n#### 引用\r\n\r\n用·\\\\·加数字可引用对应顺序的组匹配内容\r\n\r\n··js\r\nvar res = /(.)b(.)\\\\1b\\\\2/.test('abcabc') // true\r\nvar res = /y(..)(.)\\\\2\\\\1/.test('yabccab') // true\r\n··\r\n\r\n#### 嵌套\r\n\r\n··js\r\n// \\\\1 指向外层括号，\\\\2 指向内层括号\r\nvar res = /y((..)\\\\2)\\\\1/.test('yabababab') // true\r\n··\r\n\r\n#### 非捕获组\r\n\r\n·(?:x)·表示不返回该组匹配的内容\r\n\r\n··js\r\n// 正则匹配 foo 或者 foofoo\r\n'foofoo'.match(/(foo){1, 2}/) // [\"foofoo\", \"foo\"] 占用一个组匹配\r\n'foofoo'.match(/(?:foo){1, 2}/) // [\"foofoo\"] 不占用\r\n··\r\n\r\n### 具名组匹配\r\n\r\n为每一个组匹配指定一个名字，在·()·内部的开头加上·?<name>·即可\r\n\r\n··js\r\nlet reg = /(?<year>\\\\d{4})-(?<month>\\\\d{2})-(?<day>\\\\d{2})/u\r\n'2015-01-02'.replace(reg, '$<day>/$<month>/$<year>') // '02/01/2015'\r\n\r\nconst RE_DATE = /(?<year>\\\\d{4})-(?<month>\\\\d{2})-(?<day>\\\\d{2})/\r\nconst matchObj = RE_DATE.exec('1999-12-31')\r\nconst year = matchObj.groups.year // 1999\r\nconst month = matchObj.groups.month // 12\r\nconst day = matchObj.groups.day // 31\r\n··\r\n\r\n#### 引用\r\n\r\n使用·\\\\k<组名>·引用具名组匹配\r\n\r\n··js\r\nconst reg = /^(?<word>[a-z]+)_\\\\k<word>$/\r\nreg.test('abc_abc') // true\r\nreg.test('abc_ab') // false\r\n··\r\n\r\n### 断言\r\n\r\n!!\r\n先行断言：·x(?=y)·，·x·只有在·y·前面才匹配，例如匹配后面跟着百分号的数字·/\\\\d+(?=%)/·\r\n先行否定断言：·x(?!y)·，·x·只有不在·y·前面才匹配，例如要匹配后面跟的不是百分号的数字·/\\\\d+(?!%)/·\r\n后行断言：·(?<=y)x·，·x·只有在·y·后面才匹配，例如只匹配钱符号之后的数字·/(?<=￥)\\\\d+/·\r\n后行否定断言：·(?<!y)x·，·x·只有不在·y·后面才匹配，例如只匹配不在钱符号后面的数字·/(?<!￥)\\\\d+/·\r\n!!\r\n\r\n后行断言是先匹配·/(?<=y)x/·的·x·，再回到左边匹配·y·。这种先右后左与其他正则相反，会导致一些不符合预期的行为\r\n\r\n组匹配：\r\n\r\n··js\r\n// 后 2 个元素相反，因为顺序不同\r\nvar res = /^(\\\\d+)(\\\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"]\r\nvar res = /(?<=(\\\\d+)(\\\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]\r\n··\r\n\r\n引用\r\n\r\n··js\r\n// 后行断言的反斜杠引用 \\\\1 需放在括号的前面才能引用，与先行断言相反\r\nvar res = /(?<=(o)d\\\\1)r/.exec('hodor')  // null\r\nvar res = /(?<=\\\\1d(o))r/.exec('hodor')  // [\"r\", \"o\"]\r\n··\r\n\r\n### Unicode 属性类\r\n\r\n·\\\\p{...}·匹配符合 Unicode 某种属性的所有字符，反向匹配为·\\\\P{...}·\r\n**注意**使用时一定要加上·u·修饰符才能正确识别\r\nUnicode 属性类要指定属性名和属性值，某些属性可以只写属性名或属性值\r\n\r\n··js\r\nvar reg = /\\\\p{UnicodePropertyName=UnicodePropertyValue}/\r\nvar reg = /\\\\p{UnicodePropertyName}/\r\nvar reg = /\\\\p{UnicodePropertyValue}/\r\n··\r\n\r\n··js\r\n// 匹配一个希腊文字母\r\nvar res = /\\\\p{Script=Greek}/u.test('π') // true\r\n\r\n// 匹配各种数字\r\nconst regex = /^\\\\p{Number}+$/u\r\nregex.test('²³¹¼½¾') // true\r\nregex.test('㉛㉜㉝') // true\r\nregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true\r\n\r\n// 匹配 Emoji\r\nvar reg = /\\\\p{Emoji_Modifier_Base}\\\\p{Emoji_Modifier}?|\\\\p{Emoji_Presentation}|\\\\p{Emoji}\\\\uFE0F/gu\r\n··\r\n\r\n## 属性\r\n\r\n!!\r\nRegExp.prototype.global：返回 Boolean 值，表示是否设置了·g·修饰符，全局匹配\r\nRegExp.prototype.ignoreCase：返回 Boolean 值，表示是否设置了·i·修饰符，不区分大小写\r\nRegExp.prototype.multiline：返回 Boolean 值，表示是否设置了·m·修饰符，换行匹配\r\nRegExp.prototype.dotAll：返回 Boolean 值，表示是否设置了·s·修饰符，提升·.·为所有字符\r\nRegExp.prototype.sticky：返回 Boolean 值，表示是否设置了·y·修饰符，粘连匹配\r\nRegExp.prototype.unicode：返回 Boolean 值，表示是否设置了·u·修饰符，Unicode 模式\r\nRegExp.prototype.lastIndex：返回数值，表示下一次开始搜索的位置。该属性可读写，只在进行连续搜索时有意义\r\nRegExp.prototype.source：返回正则表达式内容的字符串形式\r\nRegExp.prototype.flags：返回正则表达式修饰符的字符串形式\r\n!!\r\n\r\n··js\r\nvar r = /abc/gimsyu\r\n\r\nr.global // true\r\nr.ignoreCase // true\r\nr.multiline // true\r\nr.dotAll // true\r\nr.sticky // true\r\nr.unicode // true\r\nr.lastIndex // 0\r\nr.source // \"abc\"\r\nr.flags // \"gimuys\"\r\n··\r\n\r\n## 方法\r\n\r\n字符串对象有 4 个方法可以使用正则表达式：·match()·、·replace()·、·search()·和·split()·\r\nES6 将这 4 个方法，在语言内部全部调用·RegExp·的实例方法，即所有与正则相关的方法全都定义在·RegExp·对象上\r\n·String.prototype.match·调用·RegExp.prototype[Symbol.match]·\r\n·String.prototype.replace·调用·RegExp.prototype[Symbol.replace]·\r\n·String.prototype.search·调用·RegExp.prototype[Symbol.search]·\r\n·String.prototype.split·调用·RegExp.prototype[Symbol.split]·\r\n\r\n### R.p.test()\r\n\r\n返回一个 Boolean 值，判断当前模式是否能匹配参数字符串\r\n\r\n··js\r\nvar res = /cat/.test('cats and dogs') // true\r\n··\r\n\r\n若有·g·修饰符，则每一次·test()·都从上一次结束的位置开始向后匹配\r\n\r\n··js\r\nvar r = /x/g\r\nvar s = '_x_x'\r\n\r\nr.lastIndex // 0\r\nr.test(s) // true\r\n\r\nr.lastIndex // 2\r\nr.test(s) // true\r\n\r\nr.lastIndex = 1\r\nr.test(s) // true\r\n··\r\n\r\n### R.p.exec()\r\n\r\n以数组的形式返回匹配的结果，若匹配失败返回·null·\r\n\r\n··js\r\n/x/.exec('_x_x') // [\"x\"]\r\n··\r\n\r\n如果是组匹配，则第一个成员整个匹配的结果，后面的成员与圆括号的匹配结果对应\r\n\r\n··js\r\n/_(x)/.exec('_x_x') // [\"_x\", \"x\"]\r\n··\r\n\r\n·exec·方法的返回数组还包含以下两个属性\r\n\r\n!!\r\ninput：整个原字符串\r\nindex：整个模式匹配成功的开始位置（从 0 开始计数）\r\n!!\r\n\r\n若正则表达式加上·g·全局匹配，则可以使用多次·exec·方法，下一次搜索的位置从上一次匹配成功结束的位置开始\r\n\r\n··js\r\nvar reg = /a/g\r\nvar str = 'abc_abc_abc'\r\n\r\nvar r1 = reg.exec(str)\r\nr1 // [\"a\"]\r\nr1.index // 0\r\nreg.lastIndex // 1\r\n\r\nvar r2 = reg.exec(str)\r\nr2 // [\"a\"]\r\nr2.index // 4\r\nreg.lastIndex // 5\r\n··\r\n\r\n### S.p.match()\r\n\r\n以数组的形式返回匹配的结果，若匹配失败返回·null·\r\n若没有·g·修饰符则等同于·exec()·\r\n若有·g·修饰符则返回所有匹配的结果，且没有·input·和·index·属性，也不会捕获分组的内容\r\n注意·lastIndex·属性，对·match·方法无效，匹配总是从字符串的第一个字符开始\r\n\r\n··js\r\n'abba'.match(/a/g) // [\"a\", \"a\"]\r\n··\r\n\r\n### S.p.search()\r\n\r\n返回第一个满足条件的匹配结果在整个字符串中的位置，若匹配失败返回·-1·\r\n\r\n··js\r\n'_x_x'.search(/x/) // 1\r\n··\r\n\r\n### S.p.split()\r\n\r\n·split(separator, [limit])·：返回一个根据条件分割后的各个部分组成的数组，·separator·为条件，·limit·为要分隔几个\r\n\r\n··js\r\n// 非正则分隔\r\n'a,  b,c, d'.split(',') // [ 'a', '  b', 'c', ' d' ]\r\n\r\n// 正则分隔，去除多余的空格\r\n'a,  b,c, d'.split(/, */) // [ 'a', 'b', 'c', 'd' ]\r\n··\r\n\r\n如果带有组匹配，则组匹配的部分也会作为数组成员返回\r\n\r\n··js\r\n'aaa*a*'.split(/a*/) // [\"\", \"*\", \"*\"]\r\n\r\n'aaa*a*'.split(/(a*)/) // [ '', 'aaa', '*', 'a', '*' ]\r\n··\r\n\r\n### S.p.replace()\r\n\r\n·replace(search, replacement)·：将字符串中匹配的值替换成新值，·search·为条件，·replacement·为新值\r\n\r\n··js\r\n'aaa'.replace('a', 'b') // \"baa\"\r\n'aaa'.replace(/a/, 'b') // \"baa\"\r\n'aaa'.replace(/a/g, 'b') // \"bbb\"\r\n··\r\n\r\n第二个参数可以使用·$·指代所替换的内容：\r\n\r\n!!\r\n$&：匹配的子字符串\r\n$\\`：匹配结果前面的文本\r\n$'：匹配结果后面的文本\r\n$n：组匹配的第 n 组内容\r\n$$：转义·$·\r\n!!\r\n\r\n··js\r\n'13344445555'.replace(/(\\\\d{3})\\\\d{4}(\\\\d{4})/, '$1****$2') // \"133****5555\"\r\n··\r\n\r\n第二个参数还可以是一个函数，函数的返回值为新值，函数的参数：\r\n\r\n!!\r\n第一个：每次匹配的结果\r\n第二个 ~ 倒数第三个：对应组匹配的结果（若设置了组匹配）\r\n倒数第二个：当前匹配结果在原字符串中的位置\r\n最后一个：原字符串\r\n!!\r\n\r\n··js\r\n'3 and 5'.replace(/\\\\d/g, res => 2 * res) // \"6 and 10\"\r\n\r\n'3 and 5'.replace(/\\\\d (and) \\\\d/g, (res, $1, index, str) => {\r\n    return res\r\n})\r\n··\r\n\r\n### S.p.matchAll()\r\n\r\n以遍历器（Iterator）的形式返回所有匹配的结果，可直接使用·for...of·循环\r\n\r\n··js\r\nconst string = 'test1test2test3'\r\nconst regex = /t(e)(st(\\\\d?))/g\r\nfor (const match of string.matchAll(regex)) console.log(match)\r\n// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]\r\n// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]\r\n// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\r\n··\r\n\r\n## 常用正则\r\n\r\n··js\r\n// 任意字符\r\nvar res = /./s\r\nvar res = /[^]/\r\nvar res = /[\\\\s\\\\S]/ // 类似的有 /[\\\\d\\\\D]/ 等\r\n\r\n// 中文\r\nvar res = /[\\\\u4e00-\\\\u9fa5]/\r\n\r\n// 手机号\r\nvar res = /^1[3-9]\\\\d{9}$/\r\n··\r\n\r\n&2019/4/2\r\n            `\r\n        }\r\n    }\r\n}\r\n</script>\r\n","import mod from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./regexp.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../node_modules/cache-loader/dist/cjs.js??ref--12-0!../../../../node_modules/thread-loader/dist/cjs.js!../../../../node_modules/babel-loader/lib/index.js!../../../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./regexp.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./regexp.vue?vue&type=template&id=770fee5e&\"\nimport script from \"./regexp.vue?vue&type=script&lang=js&\"\nexport * from \"./regexp.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\nexport default component.exports"],"sourceRoot":""}