(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d2244a8"],{e007:function(n,t,e){"use strict";e.r(t);var i=function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{domProps:{innerHTML:n._s(n.format(n.text))}})},g=[],a={data:function(){return{text:'\n# git\n\n## 介绍\n\n1991~2002 年，Linux 内核开源项目有着为数众多的参与者。 但绝大多数的维护工作都花在了提交补丁和保存归档的繁琐事务上\n2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码\n2005 年，开发 BitKeeper 的商业公司与 Linux 内核开源社区的合作关系结束，收回了 Linux 内核社区免费使用 BitKeeper 的权力\n这就迫使 Linux 开源社区（特别是 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统 - Git\n\n## 安装\n\n在 [Git 官网](https://git-scm.com/downloads) 下载安装\n这里使用命令行的形式，在项目目录中右键选择·Git Bash Here·，而会了命令行形式自然也理解了图形界面操作·Git GUI Here·\n\n### 使用项目托管平台\n\n在项目托管平台上建立账户，例如 GitHub、GitLab 等平台\n\n### 用户信息设置\n\n设置拥有的项目托管平台的用户名和邮件地址\n\n··bash\ngit config --global user.name "<name>"\ngit config --global user.email "<email>"\n··\n\n然后可以查看账户信息\n\n··bash\ngit config user.name\ngit config user.email\n··\n\n或查看账户全部信息\n\n··bash\ngit config --list\n··\n\n## 创建项目\n\n### 在项目托管平台创建\n\n在项目托管平台上建立项目，然后点击 clone 按钮即可复制远程项目的 url\n\n··bash\ngit clone <projectUrl>\n··\n\n然后项目就被克隆到本地了\n\n### 将已有的项目托管\n\n在项目托管平台上建立项目（最好和本地项目名称一致），然后点击 clone 按钮即可复制远程项目的 url\n\n··bash\ngit init\ngit remote add origin <projectUrl>\ngit add .\ngit commit -m "初始化项目"\ngit push origin master\n··\n\n## 常用命令\n\n### 概念\n\n![800](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png)\n\n!!\nWorkspace / Working：工作区（本地代码）\nIndex / Stage：暂存区（已 add）\nRepository：本地仓库（已 commit）\nRemote：远程仓库（例如 GitHub）\n!!\n\n### add\n\n··bash\n# 添加当前目录的所有文件到暂存区\ngit add .\n\n# 添加指定文件到暂存区\ngit add <file1> <file2> ...\n\n# 添加指定目录到暂存区\ngit add <dir>\n··\n\n### commit\n\n··bash\n# 提交暂存区到仓库区\ngit commit -m "<message>"\n\n# 提交暂存区的指定文件到仓库区\ngit commit <file1> <file2> ... -m "<message>"\n\n# 提交工作区直接到仓库区（不能提交新的文件）\ngit commit -am "<message>"\n\n# 使用一次新的 commit 替代上一次，如果代码没变化相当于改写 "<message>"\ngit commit --amend -m "<message>"\n··\n\n### branch\n\n··bash\n# 列出所有本地分支\ngit branch\n\n# 列出所有远程分支\ngit branch -r\n\n# 列出所有本地分支和远程分支\ngit branch -a\n\n# 新建一个分支，但依然停留在当前分支\ngit branch <branchName>\n\n# 切换到指定分支，并更新工作区\ngit checkout <branchName>\n\n# 新建一个分支，并切换到该分支\ngit checkout -b <branch>\n\n# 切换到上一个分支\ngit checkout -\n\n# 合并指定分支到当前分支\ngit merge <branch>\n\n# 新建分支后 push 代码即可创建对应名称的远程分支\n\n# 删除分支\ngit branch -d <branchName>\n\n# 删除远程分支\ngit push <remote> --delete <branchName>\n··\n\n### pull / push\n\n··bash\n# 拉取远程仓库的变化，并与本地分支合并\ngit pull <remote> <branch>\n\n# 上传本地指定分支到远程仓库\ngit push <remote> <branch>\n\n# 强制推送当前分支到远程仓库，即使有冲突\ngit push <remote> --force\n\n# 设置 pull / push 的默认分支，之后不用输入 <remote> <branch> 即可提交\ngit branch --set-upstream-to <remote> <branch>\n··\n\n### checkout / reset\n\n··bash\n# 还原工作区到修改前（时机在 add 之前）\ngit checkout .\n\n# 还原指定文件到修改前（时机在 add 之前）\ngit checkout <file>\n\n# 将暂存区的文件移除，不改变工作区（时机在 add 之后）\ngit reset .\n\n# 将暂存区指定的文件移除，不改变工作区（时机在 add 之后）\ngit reset <file>\n\n# 重置暂存区与工作区，与上一次 commit 保持一致\ngit reset --hard\n\n# 重置暂存区与工作区，与指定 commit 保持一致\ngit reset --hard <commit>\n··\n\n### stash\n\n··bash\n# 储存工作区并还原到修改前（通常用于切换到其他分支而不想提交）\ngit stash\n\n# 查看储存记录\ngit stash list\n\n# 将最近的一次储存还原到工作区\ngit stash apply\n\n# 将最近的一次储存还原到工作区并删除此存储\ngit stash pop\n\n# 删除指定的存储\ngit stash drop <stash@{n}>\n\n# 删除所有存储\ngit stash clear\n··\n\n### tag\n\n给历史中的某一个提交打上标签，以示重要，例如版本号\n\n··bash\n# 列出所有tag\ngit tag\n\n# 新建一个 tag 在当前 commit\ngit tag <tag>\n\n# 新建一个 tag 在指定校验和（或部分校验和，一般是前 7 位）\ngit tag <tag> <commit>\n\n# 删除本地 tag\ngit tag -d <tag>\n\n# 删除远程 tag\ngit push origin :refs/tags/<tagName>\n\n# 查看 tag 信息\ngit show <tag>\n\n# 提交指定 tag\ngit push <remote> <tag>\n\n# 提交所有 tag\ngit push <remote> --tags\n\n# 新建一个分支，指向某个 tag\ngit checkout -b <branch> <tag>\n··\n\n### status / log 相关\n\n··bash\n# 显示有变更的文件\ngit status\n\n# 精简显示有变更的文件\ngit status -s\n\n# 显示当前分支的版本历史\ngit log\n\n# 精简显示 commit 历史\ngit log --pretty=oneline\n\n# 精简显示 commit 历史并只展示最近的几次\ngit log --pretty=oneline -<n>\n\n# 显示 commit 历史，以及每次 commit 发生变更的文件\ngit log --stat\n\n# 搜索提交历史，根据关键词\ngit log -S <keyword>\n\n# 显示某个文件的版本历史\ngit log --follow <file>\n\n# 显示所有提交过的用户，按提交次数排序\ngit shortlog -sn\n\n# 显示指定文件是什么人在什么时间修改过\ngit blame <file>\n\n# 显示某次提交的元数据和内容变化\ngit show <commit>\n\n# 显示当前分支的最近几次提交\ngit reflog\n··\n\n### diff\n\n··bash\n# 显示暂存区和工作区的差异\ngit diff\n\n# 显示工作区与当前分支最新 commit 之间的差异\ngit diff HEAD\n\n# 显示两次提交之间的差异\ngit diff <first-branch>...<second-branch>\n\n# 显示今天写了多少行代码\ngit diff --shortstat "@{0 day ago}"\n··\n\n### 版本回退\n\n··bash\n# 查看提交记录，复制 commit 串\ngit log --pretty=oneline\n\n# 回到指定版本\ngit reset --hard <commit>\n··\n\n#### 方式一：强制覆盖提交\n\n··bash\ngit push <remote> --force\n··\n\n如果提示拒绝则可能项目被保护了\n在项目托管平台上的当前项目中设置（例如 GitLab）：Settings - Repository - Protected Branches - 点击 Unprotect\n\n#### 方式二：重新建立分支\n\n··bash\n# 复制临时分支\ngit checkout -b temp\ngit push <remote> temp\n\n# 删除主分支\ngit branch -d master\ngit push <remote> --delete master\n\n# 新建主分支\ngit checkout -b master\ngit push <remote> master\n\n# 删除临时分支\ngit branch -d temp\ngit push <remote> --delete temp\n··\n\n如果删除默认分支可能失败，先改为其他分支即可\n\n## .gitignore\n\n.gitignore 文件可以让 Git 不上传哪些文件，比如 node_modules 文件是没必要上传的\n在项目的根目录建立这个文件·.gitignore·，写出路径即可，例如：\n\n··bash\nREADME.md # 根目录下的文件\nbash/README.md # 文件夹内的文件\n*.md # 根目录下的所有 .md 文件\n**/*.md # 该项目中所有 .md 文件\n!README.md # 不忽略，即逃离 *.md 和 **/*.md 的范围\nnode_modules/ # 根目录下的 node_modules 文件夹\n··\n\n## 常见问题\n\n!!\n若当前 git 命令返回的信息过长或出现错误，即不能输入命令的情况下，按·Q·键即可退出\n·git add .·半天没反应的话，应该是有大文件，比如 node_modules 文件，用 .gitignore 忽略即可\n提示·fatal: Unable to create .git/index.lock\': File exists.·错误，在·.git·文件夹内（项目根目录的隐藏文件夹）删除·index.lock·即可\n!!\n\n@@\n[git 官网](https://git-scm.com)\n[git 中文网](https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)\n@@\n\n&2019/10/13\n'}}},o=a,s=e("2877"),m=Object(s["a"])(o,i,g,!1,null,null,null);t["default"]=m.exports}}]);
//# sourceMappingURL=chunk-2d2244a8.5e3e8142.js.map