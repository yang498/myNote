(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-2d207e8f"],{a318:function(n,e,o){"use strict";o.r(e);var r=function(){var n=this,e=n.$createElement,o=n._self._c||e;return o("div",{domProps:{innerHTML:n._s(n.format(n.text))}})},s=[],t={data:function(){return{text:"\n# es6\n\n## 概述\n\nECMAScript 6.0 版（简称 ES6）是 JavaScript 语言的下一代标准，已在 2015 年 6 月正式发布\n\n### ECMAScript\n\nECMAScript 和 JavaScript 的关系：\n\n!!\n1996 年 11 月，JavaScript 的创造者 Netscape 公司将 JavaScript 提交给标准化组织 ECMA，希望能成为国际标准\n次年，ECMA 规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版\n之所以不叫 JavaScript，有两个原因\n    一是商标，Java 是 Sun 公司的商标，只有 Netscape 公司可以合法使用，且 JavaScript 也是 Netscape 公司的商标\n    二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性\n因此 ECMAScript 是 JavaScript 的标准规格，JavaScript 是 ECMAScript 的一种实现，日常场合这两个词可以互换\n!!\n\n### ES2015\n\nECMAScript 2015（简称 ES2015）和 ES6 的关系：\n\n!!\n2011 年 ECMAScript 5.1 版发布后，就开始制定 6.0 版了\n但标准委员会为了更好的改进和发展，决定不再以 6.1、6.2 这种版本记号，改成以年份为标记\nES6 的第一个版本在 2015 年发布，正式名称就是《ECMAScript 2015 标准》\n因此 ES6 是个泛指，含义是 5.1 版以后的 JavaScript 下一代标准，包括 ES2015、ES2016、ES2017 等等\n!!\n\n## Promise\n\n### 概述\n\n异步编程的一种解决方案，简单说就是一个容器，里面保存一个异步操作的结果\n有三种状态：·pending·（进行中）、·fulfilled·（已成功）和·rejected·（已失败）\n·Promise·的构造函数接受一个函数，且有两个参数方法 ·resolve· 和 ·reject·\n·resolve·是成功时执行的函数，·reject·是失败时执行的函数\n若调用·resolve·和·reject·时带有参数将会传递给回调函数，·reject·通常传递·Error·对象的实例\n\n··js\nconst promise = new Promise((resolve, reject) => {\n    setTimeout(() => {\n        if (/* 异步操作成功 */){\n            resolve()\n        } else {\n            reject(new Error())\n        }\n    }, 1000)\n})\n··\n\n### then()\n\n·Promise.prototype.then()·：监听 Promise 的状态变化，接受两个回调函数作为参数，分别在成功和失败时执行\n\n··js\npromise.then(value => {\n    console.log('成功')\n}, error => {\n    console.log('失败')\n})\n··\n\nPromise 新建后回调函数会立即执行，·resolve· 和 ·reject· 异步执行：\n\n··js\nconst promise = new Promise((resolve, reject) => {\n    resolve('1')\n    console.log('2')\n})\npromise.then(res => console.log(res))\nconsole.log('3')\n\n// 2\n// 3\n// 1\n··\n\n·then·会返回的新的 Promise 实例。因此可以采用链式写法，且前一个·then·返回的值可作为后一个·then·的参数使用：\n··js\npromise.then(() => {\n    return 123\n}).then(res => {\n    console.log(res) // 123\n})\n··\n\n如果前一个·then·返回的还是一个 Promise 对象，这时后一个·then·就会监听该 Promise 的状态变化：\n\n··js\nconst p = new Promise(resolve => {\n    setTimeout(() => resolve('p'), 2000)\n})\nconst p1 = new Promise(resolve => {\n    setTimeout(() => resolve('p1'), 1000)\n})\np.then(res => {\n    console.log(res) // p （2 秒后触发）\n    return p1 // （p1 的状态 1 秒已改变）\n}).then(res => {\n    console.log(res) // p1 （上一个 then 触发完毕立即触发）\n})\n··\n\n如果·resolve·的参数是 Promise 对象，则·then·会变成监听那个 Promise 对象\n\n··js\nconst p1 = new Promise(function (resolve, reject) {\n  setTimeout(() => reject(new Error('fail')), 3000)\n})\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() => resolve(p1), 1000) // 1 秒后发现是传递 Promise 对象，所以 p2 的状态无效，改成由 p1 决定\n})\np2.then(result => {\n    console.log(result)\n}).catch(error => {\n    console.log(error) // Error: fail（3 秒后触发）\n})\n··\n\n### catch()\n\n·Promise.prototype.catch()·：发生错误时触发，即·.then(null, fn)·的别名\nPromise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获：\n\n··js\nconst p = new Promise((resolve, reject) => resolve('p'))\nconst p1 = new Promise((resolve, reject) => reject(new Error('p1')))\nconst p2 = new Promise((resolve, reject) => resolve('p1'))\np.then(res => {\n    return p1\n}).then(res => {\n    return p2\n}).then(res => {\n    console.log(res)\n}).catch(error => {\n    // 处理前面所有 Promise 中第一个产生的错误\n    console.log(error) // Error: p1\n})\n··\n\nPromise 内部的错误不会影响到 Promise 外部的代码：\n\n··js\nconst promise = new Promise((resolve, reject) => {\n    resolve(x + 2) // 报错，x 没有声明\n})\npromise.then(function() {\n    console.log('everything is great')\n})\nsetTimeout(() => { console.log(123) }, 2000)\n\n// Uncaught (in promise) ReferenceError: x is not defined\n// 123\n··\n\n### finally()\n\n·Promise.prototype.finally()·：不管 Promise 对象最后状态如何都会执行的操作，即：\n\n··js\npromise.finally(() => console.log(123))\n// 等同于\npromise.then(() => console.log(123), () => console.log(123))\n··\n\n具体实现：\n\n··js\nPromise.prototype.finally = function (callback) {\n    const P = this.constructor\n    return this.then(\n        value  => P.resolve(callback()).then(() => value),\n        reason => P.resolve(callback()).then(() => { throw reason })\n    )\n}\n··\n\n### Promise.all()\n\n将多个 Promise 实例包装成一个新的 Promise 实例，接受一个由 Promise 对象数组作为参数\n\n··js\n// p1、p2、p3 都是 Promise 对象\nconst p = Promise.all([p1, p2, p3])\np.then(list => {\n    // ...\n}).catch(error => {\n    // ...\n})\n··\n\n上面的代码中·p·的状态由·p1 p2 p3·决定\n如果都成功·p·才会触发·then·，并会将·p1 p2 p3·的返回值组成数组传给·p·\n如果有一个失败·p·就会触发·catch·，并会将第一个失败的返回值会传递给·p·\n注意，如果参数自己定义并触发了·catch·方法，并不会触发·Promise.all()·的·catch·，而是触发·then·\n\n### Promise.race()\n\n用法同·Promise.all()·，·p·的状态取决于·p1 p2 p3·中第一个改变的状态，第一个改变的返回值会传递给·p·\n\n··js\n// 超时处理：5 秒内无结果就会触发 catch\nconst p = Promise.race([\n    fetch('/resource-that-may-take-a-while'),\n    new Promise((resolve, reject) => {\n        setTimeout(() => reject(new Error('request timeout')), 5000)\n    })\n])\n\np\n.then(console.log)\n.catch(console.error)\n··\n\n### Promise.allSettled()\n\n用法同·Promise.all()·，不管·p1 p2 p3·的状态，都触发完毕·p·就会触发·then·，且参数为所有结果的返回值组成的数组\n该数组的格式为固定格式的对象数组，形如：\n··js\n[\n    { status: \"fulfilled\", value: 1 }, // 成功\n    { status: \"rejected\", reason: 2 } // 失败\n]\n··\n\n··js\n// 输出失败的请求\nconst p = Promise.allSettled([ fetch('index.html'), fetch('https://does-not-exist/') ])\np.then(list => {\n    list.filter(item => item.status === 'rejected').map(item => item.reason)\n})\n··\n\n### Promise.any()\n\n用法同·Promise.all()·，·p1 p2 p3·只要有一个成功就触发·then·，都失败才触发·catch·，和·Promise.all()·相反\n注意·catch·接受的错误数组是个由·AggregateError·组成的数组\n\n### Promise.resolve()\n\n将参数转为 Promise 对象，参数分成四种情况：\n\n#### Promise 实例将不做任何修改直接返回这个实例\n\n#### 不传参数直接·resolve·一个 Promise 对象\n\n#### 定义了·then·方法的对象会立即执行\n\n··js\nconst p = Promise.resolve({\n    then (resolve, reject) {\n        resolve(123)\n    }\n})\np.then(console.log) // 123\n··\n\n#### 未定义了·then·方法的对象或其他值直接·resolve·这个值\n\n··js\nPromise.resolve('foo')\n// 等同于\nnew Promise(resolve => resolve('foo'))\n··\n\n注意立即·resolve()·的 Promise 对象，是在本轮事件循环结束时执行，而不是在下一轮的开始时\n\n··js\nsetTimeout(() => console.log(3))\nPromise.resolve().then(() => console.log(2)\nconsole.log(1)\n// 1\n// 2\n// 3\n··\n\n### Promise.reject()\n\n将参数转为 Promise 对象，并直接·reject·这个值，不管参数是什么\n\n··js\nconst p = Promise.reject('出错了')\n// 等同于\nconst p = new Promise((resolve, reject) => reject('出错了'))\n··\n\n### Promise.try()\n\n有时候不知道或者不想区分函数·f·是同步还是异步操作，想用 Promise 统一处理\n但如果·f·是同步函数则会在本轮事件循环的末尾执行，本意是让同步函数同步执行，异步函数异步执行：\n\n··js\nconst f = () => console.log('now')\nPromise.resolve().then(f)\nconsole.log('next')\n// next\n// now\n··\n\n·try·方法就可以做到：\n\n··js\nconst f = () => console.log('now')\nPromise.try(f)\nconsole.log('next')\n// now\n// next\n··\n\n@@\n[ECMAScript 6 入门](http://es6.ruanyifeng.com/)\n@@\n\n&2020/06/06\n"}}},l=t,c=o("2877"),i=Object(c["a"])(l,r,s,!1,null,null,null);e["default"]=i.exports}}]);
//# sourceMappingURL=chunk-2d207e8f.b693909a.js.map